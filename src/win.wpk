local names = {}
local values = {}
table.insert(names, "/assets/Miku/balloon.pic")
table.insert(values, [[pic|8|21|a0 a0 a0 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 a0 a0 a0 a0 90 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 90 a0 a0 a0 90 0f 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 90 a0 a0 90 00 0f 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 90 a0 a0 90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 90 a0 a0 90 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 a0 a0 a0 90 90 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 90 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 ]])
table.insert(names, "/assets/Miku/down.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 90 90 e0 90 90 90 90 90 e0 90 90 00 00 90 90 90 40 40 40 40 40 90 90 90 00 90 90 90 40 a0 a0 40 a0 a0 40 00 90 00 90 90 00 40 a0 f0 40 a0 f0 40 00 90 90 90 00 00 40 40 40 40 40 40 40 00 90 90 90 00 00 f0 90 40 40 40 90 f0 00 00 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 00 90 90 0f 0f 40 f0 90 90 90 f0 40 00 00 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/happy1.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 90 90 90 40 40 40 40 40 90 90 00 00 00 90 90 40 f0 40 40 40 f0 40 90 90 00 90 90 00 f0 40 f0 40 f0 40 f0 00 90 90 90 90 00 40 40 40 40 40 40 40 00 90 90 90 90 00 f0 90 40 40 40 90 f0 00 90 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 90 90 90 0f 0f 40 f0 90 90 90 f0 40 00 90 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/happy2.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 90 90 90 40 40 40 40 40 90 90 00 00 00 90 90 40 f0 40 40 40 f0 40 90 90 00 90 90 00 f0 40 f0 40 f0 40 f0 00 90 90 90 90 00 40 60 40 40 40 60 40 00 90 90 90 90 00 f0 90 40 40 40 90 f0 00 90 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 90 90 90 0f 0f 40 f0 90 90 90 f0 40 00 90 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/idle.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 90 90 90 40 40 40 40 40 90 90 00 00 00 90 90 40 a0 f0 40 f0 a0 40 90 90 00 90 90 00 40 a0 f0 40 f0 a0 40 00 90 90 90 90 00 40 40 40 40 40 40 40 00 90 90 90 90 00 f0 90 40 40 40 90 f0 00 90 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 90 90 90 0f 0f 40 f0 90 90 90 f0 40 00 90 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/s1.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 90 90 90 40 40 40 40 40 90 90 00 00 00 90 90 40 a0 a0 40 a0 a0 40 90 90 00 90 90 00 40 a0 f0 40 a0 f0 40 00 90 90 90 90 00 40 40 40 40 40 40 40 00 90 90 90 90 00 f0 90 40 40 40 90 f0 00 90 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 90 90 90 0f 0f 40 f0 90 90 90 f0 40 00 90 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/s2.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 90 90 90 40 40 40 40 40 90 90 00 00 00 90 90 40 a0 a0 40 a0 a0 40 90 90 00 90 90 00 40 f0 a0 40 f0 a0 40 00 90 90 90 90 00 40 40 40 40 40 40 40 00 90 90 90 90 00 f0 90 40 40 40 90 f0 00 90 90 90 00 f0 f0 f0 90 f0 90 f0 f0 f0 90 90 90 0f 0f 40 f0 90 90 90 f0 40 00 90 90 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/assets/Miku/up.pic")
table.insert(values, [[pic|10|13|00 00 e0 90 90 90 90 90 90 90 e0 00 00 00 00 90 e0 90 90 90 90 90 e0 90 00 00 00 00 90 90 40 40 40 40 40 90 90 00 00 00 00 90 40 a0 a0 40 a0 a0 40 90 00 00 00 90 90 40 a0 f0 40 a0 f0 40 90 90 00 00 90 90 40 40 40 40 40 40 40 90 90 00 00 90 90 f0 90 40 40 40 90 f0 90 90 00 00 90 f0 f0 f0 90 f0 90 f0 f0 90 90 00 00 90 0f 40 f0 90 90 90 f0 40 90 90 00 0f 0f 00 f0 90 90 90 90 90 f0 00 0f 00 ]])
table.insert(names, "/drivers/etc/hosts")
table.insert(values, [[%.cw	http://www.mypascal.url.ph/ccwin/dns/?url=%BASEURL_ENCODED%]])
table.insert(names, "/drivers/http.app")
table.insert(values, [[local running = true
local downloading = {}
local hosts = {}


os.getProcessInfo(hwnd).showInTaskbar = false
os.getProcessInfo(hwnd).title = "Http service"
kernel.kiRegisterEventReceiver("http_success")
kernel.kiRegisterEventReceiver("http_failure")

if fs.exists(kernel.env.GetOsPath() .. "drivers/etc/hosts") then
	local file = fs.open(kernel.env.GetOsPath() .. "drivers/etc/hosts", "r")
	local data = file.readAll()
	file.close()

	data = string.gsub(data, "\r", "")

	local h = user.split(data, "\n")
	for i, v in ipairs(h) do
		local hostData = user.split(v, "	")
		hosts[hostData[1\]\] = hostData[2]
	end
end


function getRequestURL(baseURL)
	for k, v in pairs(hosts) do
		if string.match(baseURL, k) then
			local oldBaseURL = baseURL
			baseURL = string.gsub(baseURL, "%?", "%%%?")
			baseURL = string.gsub(baseURL, "%/", "%%%/")
			baseURL = string.gsub(baseURL, "%\\", "%%%\\")
			baseURL = string.gsub(baseURL, "%&", "%%%&")
			baseURL = string.gsub(baseURL, "%.", "%%%.")
			baseURL = string.gsub(baseURL, "%:", "%%%:")
			baseURL = string.gsub(baseURL, "%^", "%%%^")
			baseURL = string.gsub(baseURL, "%$", "%%%$")
			baseURL = string.gsub(v, "%%BASEURL%%", baseURL)
			baseURL = string.gsub(baseURL, "%%BASEURL_ENCODED%%", string.gsub(kernel.env.textutils.urlEncode(oldBaseURL), "%%", "%%%%"))
		end
	end

	return baseURL
end




while running do
	local message = os.getMessage(hwnd)

	if message ~= nil then
		if message.msg == "request" then
			--pcall(function()
				table.insert(downloading, { url = getRequestURL(message.url), postData = message.postData, headers = message.headers, 
					onSuccess = message.onSuccess, onFail = message.onFail })
				kernel.env.http.request(getRequestURL(message.url), message.postData, message.headers)
			--end)
		end

		if message.msg == "http_success" then
			local removal = {}

			for k, v in pairs(downloading) do
				if v.url == message.arg1 then
					v.onSuccess(message.arg1, message.arg2)
					table.insert(removal, k)
				end
			end

			for k, v in pairs(removal) do
				table.remove(downloading, k)
			end

			removal = nil
		end

		if message.msg == "http_failure" then
			local removal = {}

			for k, v in pairs(downloading) do
				if v.url == message.arg1 then
					v.onFail(message.arg1)
					table.insert(removal, k)
				end
			end

			for k, v in pairs(removal) do
				table.remove(downloading, k)
			end

			removal = nil
		end


		--if (#downloading > 0) and (current == nil) then
		--	current = table.remove(downloading)
			
		--end
	end
end


kernel.kiUnRegisterEventReceiver("http_success")
kernel.kiUnRegisterEventReceiver("http_failure")]])
table.insert(names, "/drivers/kernel")
table.insert(values, [[local processes = {}
local activeProcesses = {}
local eventHandlers = {}
local config = { timer = 0.1, desktop_color = colors.cyan, version = "0.9" }
local running = true
local screen = nil
local clipboard = { data = nil, dType = "null" }

local lastCursorBlink = false
local lastMenu = nil
local systemMessage = nil

local CURRENT_PROCESS = 0
local ACTIVE_PROCESS = 0
local NEW_ACTIVE_PROCESS = 0
local TASKBAR_PROCESS = 0
local DESKTOP_PROCESS = 0
local SHUTDOWN_PROCESS = 0

local ETIME = 0
local PROCESS_MAX_ITERATIONS = 10

local LASTHWND = 10
local CARETX = 0
local CARETY = 0
local CARETV = false
local CARETCOLOR = colors.black

local legacyShell = shell




function table.val_to_str ( v )
  if "string" == type( v ) then
    v = string.gsub( v, "\n", "\\n" )
    if string.match( string.gsub(v,"[^'\"]",""), '^"+$' ) then
      return "'" .. v .. "'"
    end
    return '"' .. string.gsub(v,'"', '\\"' ) .. '"'
  else
    return "table" == type( v ) and table.tostring( v ) or
      tostring( v )
  end
end

function table.key_to_str ( k )
  if "string" == type( k ) and string.match( k, "^[_%a][_%a%d]*$" ) then
    return k
  else
    return "[" .. table.val_to_str( k ) .. "]"
  end
end

function table.tostring( tbl )
  local result, done = {}, {}
  for k, v in ipairs( tbl ) do
    table.insert( result, table.val_to_str( v ) )
    done[ k ] = true
  end
  for k, v in pairs( tbl ) do
    if not done[ k ] then
      table.insert( result,
        table.key_to_str( k ) .. "=" .. table.val_to_str( v ) )
    end
  end
  return "{" .. table.concat( result, "," ) .. "}"
end

function string.ends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end









local function pullEvent(filter)
	local message = GetMessage(GetCurrentProcess())

	if message ~= nil then
		if ((filter == message.msg) and (filter ~= nil)) or (filter == nil) then
			if message.msg == "char" then
				return message.msg, message.char
			end
			if message.msg == "key" then
				return message.msg, message.key
			end
			if message.msg == "mouse_click" then
				return message.msg, message.button, message.x, message.y
			end
			if message.msg == "mouse_drag" then
				return message.msg, message.button, message.x, message.y
			end
			if message.msg == "mouse_scroll" then
				return message.msg, message.button, message.n
			end
		end
	else
		return pullEvent(filter)
	end
end

local oldFsExists = fs.exists

--fs.exists = function(path)
--	if string.find(path, "home:/") then
		--path = string.gsub(path, "home:/", "", 1)
--	end

--	oldFsExists(path)
--end
function getPath(path)
	if string.find(path, "home:/") then
		path = string.gsub(path, "home:/", "", 1)
	end

	return path
end



function GetCurrentProcess()
	return CURRENT_PROCESS
end

function GetProcessInfo(hwnd)
	if hwnd > 0 then
		return processes[hwnd]
	else
		return {}
	end
end


function Shell(command)
	local path = { GetOsPath() .. "/system2/" }
	local name = ""

	local cmd = pathutils.expand(command)

	if string.starts(cmd[1], "home:/") then
		path = { pathutils.extractFilePath(cmd[1]) }
		name = pathutils.extractFileName(cmd[1])

		--error(path[1])
	else
		--error(command)
		--error(cmd[2])
		table.insert(path, pathutils.extractFilePath(cmd[1]))
		name = cmd[1]
	end

	--error(name .. " " .. path[1])
	ShellRun(name, cmd, path)
end


local function CreateProcess(fileName, params, kernelMode)
	local hwnd = LASTHWND--10000
	local x, y = term.getSize()

	while (processes[hwnd] ~= nil) do
		--hwnd = math.random(65534) + 1
		hwnd = hwnd + 1
	end

	LASTHWND = hwnd


	local canvas = user.CreateCanvas(x, y - 1)
	canvas.autoScroll = true

	local process = {
		hwnd = hwnd,
		fileName = fileName,
		thread = nil,
		canvas = canvas,
		title = fs.getName(fileName),
		suspended = false,
		env = nil,
		messages = {},
		showInTaskbar = true,
		message = nil,
		etime = 0,
		iterations = 0,
		legacyMode = true,
	}

	if string.ends(fileName, ".app") then
		process.legacyMode = false
	end


	local program = assert(loadfile(fileName)--\[\[, "File '" .. fileName .. "' not found."\]\])
	process.program = program
	local timer = {
			enabled = false,
			interval = 0,
			value = 0,
			onTimer = nil,
		}


	--local nativeCanvas = {}
	--if process.legacyMode or true then
	local width, height = term.getSize()
	local nativeCanvas = window.create(term.native(), 1, 2, width, height - 2)
	nativeCanvas.setBackgroundColor(colors.black)
	nativeCanvas.setTextColor(colors.white)
	nativeCanvas.write("Loading...")
	nativeCanvas.setCursorPos(1, 2)
	nativeCanvas.setCursorBlink(true)
	nativeCanvas.setVisible(false)
	--end

	local legacyEnv = {
		error = error,
		pcall = pcall,
		xpcall = xpcall,
		tostring = tostring,
		tonumber = tonumber,
		pairs = pairs,
		ipairs = ipairs,
		assert = assert,

		dofile = dofile,
		getfenv = getfenv,
		getmetatable = getmetatable,
		load = load,
		loadfile = loadfile,
		loadstring = loadstring,
		module = module,
		next = next,
		pcall = pcall,
		rawequal = rawequal,
		rawget = rawget,
		rawset = rawset,
		require = require,
		select = select,
		setfenv = setfenv,
		setmetatable = setmetatable,
		type = type,
		unpack = unpack,
		xpcall = xpcall,
		print = print,
		read = read,
		write = nativeCanvas.write,
		printError = printError,

		bit = bit,
		colors = colors,
		colours = colors,
		coroutine = coroutine,
		disk = disk,
		fs = fs,
		gps = gps,
		help = help,
		http = {},
		io = io,
		keys = keys,
		math = math,
		paintutils = paintutils,
		parallel = parallel,
		peripheral = peripheral,
		rednet = rednet,
		redstone = redstone,
		string = string,
		table = table,
		textutils = textutuls,
		vector = vector,
		window = window,


		--multishell = {},
		os = {
			version = function()
				return "CraftOS Emulator"
			end,

			getComputerID = os.getComputerID,
			getComputerLabel = os.getComputerLabel,
			setComputerLabel = os.setComputerLabel,

			run = function(environment, programPath, args)
				args = args or {}
				if type(args) ~= "table" then
					args = {args}
				end

				local s = ""
				for i, v in ipairs(args) do
					s = s .. " " .. v
				end
				Shell(programPath .. s)
			end,

			loadAPI = os.loadAPI,
			unloadAPI = os.unloadAPI,
			pullEvent = pullEvent,

			pullEventRaw = function()
				return coroutine.yield()
			end,

			queueEvent = os.queueEvent,
			clock = os.clock,
			startTimer = os.startTimer,
			cancelTimer = os.cancelTimer,
			time = os.time,
			sleep = os.sleep,
			day = os.day,
			setAlarm = os.setAlarm,
			cancelAlarm = os.cancelAlarm,

			shutdown = function()
				processes[hwnd].kill = true
			end,

			reboot = function()
				processes[hwnd].kill = true
			end,
		},

		shell = {
			exit = function()
				processes[hwnd].kill = true
			end,

			dir = function()
				return pathutils.extractFilePath(processes[hwnd].fileName)
			end,

			setDir = function()
				-- TODO: Implement SetDir
			end,

			path = legacyShell.path,
			setPath = legacyShell.setPath,
			resolve = legacyShell.resolve,
			resolveProgram = legacyShell.resolveProgram,
			aliases = legacyShell.aliases,
			setAlias = legacyShell.setAlias,
			clearAlias = legacyShell.clearAlias,
			programs = legacyShell.programs,

			getRunningProgram = function()
				return processes[hwnd].fileName
			end,

			run = function(cmd, args)
				local args = args or {}
				local s = cmd
				for i, v in ipairs(args) do
					s = s .. " " .. v
				end
				Shell(programPath + s)
			end,

			openTab = function()
			end,

			switchTab = function()
			end,
		},
		term = nativeCanvas,
	}

	local env = {
		hwnd = hwnd,
		canvas = canvas,
		params = params,
		colors = colors,
		coroutine = coroutine,
		error = error,
		pcall = pcall,
		xpcall = xpcall,
		tostring = tostring,
		tonumber = tonumber,
		pairs = pairs,
		ipairs = ipairs,
		assert = assert,

		dofile = dofile,
		getfenv = getfenv,
		getmetatable = getmetatable,
		load = load,
		loadfile = loadfile,
		loadstring = loadstring,
		module = module,
		next = next,
		pcall = pcall,
		rawequal = rawequal,
		rawget = rawget,
		rawset = rawset,
		require = require,
		select = select,
		setfenv = setfenv,
		setmetatable = setmetatable,
		type = type,
		unpack = unpack,
		xpcall = xpcall,

		string = string,
		table = table,
		textutils = textutils,
		timer = timer,
		application = application,
		form = form,
		user = user,
		math = math,
		iniFiles = iniFiles,
		fs = fs, --------TODO: replace with alter rel
		keys = keys,
		bit = bit,
		parallel = parallel,
		peripheral = peripheral, -------------TODO: replace
		rednet = rednet, -----------------TODO: replace
		redstone = redstone,
		turtle = turtle,
		vector = vector,
		disk = disk,

		legacyEnv = legacyEnv,


		print = function(...)
			local printResult = ""

			for i, v in ipairs(arg) do
				printResult = printResult .. tostring(v)
			end

			canvas:print(printResult)
		end,

		term = {
			write = function(s)
				canvas:write(s)
			end,

			clear = function()
				canvas:fillrect(1, 1, canvas.size.x, canvas.size.y, canvas.bgcolor)
			end,

			clearLine = function()
				canvas:fillrect(1, canvas.cursorPos.y, canvas.size.x, 1, canvas.bgcolor)
			end,

			getCursorPos = function()
				return canvas:getCursorPos()
			end,

			setCursorPos = function(x, y)
				canvas:setCursorPos(x, y)
			end,

			setCursorBlink = function(bool)
				-- TODO
			end,

			isColor = function()
				return true
			end,

			getSize = function()
				return canvas.size.x, canvas.size.y
			end,

			scroll = function(n)
				-- TODO
			end,

			redirect = function(target)
				-- TODO
			end,

			setTextColor = function(color)
				canvas.forecolor = color
			end,

			setBackgroundColor = function(color)
				canvas.bgcolor = color
			end,
		},

		os = {
			sendMessage = SendMessage,
			getMessage = GetMessage,


			pullEvent = pullEvent,

			pullEventRaw = function()
				return coroutine.yield()
			end,

			startTimer = function(timeout, onTimer)
				timer.enabled = true
				timer.interval = timeout
				timer.onTimer = onTimer
			end,

			getValidHWNDList = function(onlyInTaskbar)
				local list = {}
				local i = 0

				for k, v in pairs(processes) do
					if onlyInTaskbar == true then
						if v.showInTaskbar then
							table.insert(list, k)
							i = i + 1
						end
					else
						table.insert(list, k)
						i = i + 1
					end
				end

				table.sort(list)

				--list.count = i
				return list
			end,

			setActiveProcess = function(hwnd)
				NEW_ACTIVE_PROCESS = hwnd
			end,

			getActiveProcess = function()
				return ACTIVE_PROCESS
			end,

			redirectTerm = function(obj)
				term.redirect(obj)
			end,

			restoreTerm = function()
				term.redirect(term.native())
			end,

			killProcess = function(hwnd)
				processes[hwnd].kill = true
			end,


			getRegistryBranches = function()
				iniFile = iniFiles.read("home:/" .. GetOsPath() .. "/system2/win.ini")
				list = {}
				for k, v in pairs(iniFile) do
					table.insert(list, k)
				end
				return list
			end,

			getRegistryBranchKeys = function(branch)
				iniFile = iniFiles.read(GetOsPath() .. "/system2/win.ini")
				list = {}
				for k, v in pairs(iniFile[branch] or {}) do
					table.insert(list, k)
				end
				return list
			end,

			getRegistryKeyValue = function(branch, key, default)
				iniFile = iniFiles.read(GetOsPath() .. "/system2/win.ini")
				if iniFile[branch] ~= nil then
					return iniFile[branch][key] or default
				else
					return default
				end
			end,

			setRegistryKeyValue = function(branch, key, value)
				iniFile = iniFiles.read(GetOsPath() .. "/system2/win.ini")
				if iniFile[branch] == nil then
					iniFile[branch] = {}
				end
				iniFile[branch][key] = value
				iniFiles.write(GetOsPath() .. "/system2/win.ini", iniFile)
			end,


			listInstalledSoftware = function()
				local placeholder = {{title = "Notepad", path = GetOsPath() .. "/system2/notepad.app \"%FILENAME\""}}
				return placeholder
				-- ToDo: Installation registry
			end,


			shell = {
				run = Shell,

				expandEnvVar = function(envvar)

				end,

				shutdown = function()
					os.shutdown()
				end,

				restart = function(bootToShell)
					if bootToShell then
						local file = fs.open(".reboot", "w")
						file.write("LOADTO CRAFTOS")
						file.close()
					end

					os.reboot()
				end,
			},


			extractFilePath = pathutils.extractFilePath,
			extractFileName = pathutils.extractFileName,
			extractRealFileName = pathutils.extractRealFileName,


			messageBox = function(uType, text, caption, buttons, defText)
				if uType == "input" then
					processes[hwnd].message = dialogs.InputBoxCreate({ 
						uType = uType, 
						text = text, 
						caption = caption, 
						buttons = buttons, 
						defText = defText }, 
					screen, button)
				else
					processes[hwnd].message = dialogs.MessageBoxCreate({ 
						uType = uType, 
						text = text, 
						caption = caption, 
						buttons = buttons, 
						defText = defText }, 
					screen, button)
				end
			end,


			hideMessageBox = function()
				processes[hwnd].message = nil
				processes[hwnd].canvas.effect = nil
			end,


			getProcessInfo = function(pid)
				local info = GetProcessInfo(pid)

				if pid ~= hwnd then
					local pinfo = {}

					local pinfo = {
						canvas = info.canvas,
						hwnd = info.hwnd,
						fileName = info.fileName,
						title = info.title,
						showInTaskbar = info.showInTaskbar,
						etime = info.etime,
					}

					return pinfo
				else
					return info
				end
			end,

			getCurrentProcess = GetCurrentProcess,
			getSystemPath = GetOsPath,

			copyToClipboard = function(data, dType)
				clipboard.data = data
				clipboard.dType = dType
			end,

			pasteFromClipboard = function(dType)
				if (clipboard.dType == dType) or (dType == nil) then
					return clipboard.data
				else
					return nil
				end
			end,

			applyMagic = function(effect)
				screen.effect = effect
			end,

			getMagic = function()
				return screen.effect
			end,

			setCaretPos = function(x, y)
				CARETX = x
				CARETY = y
			end,

			showCaret = function()
				CARETV = true
			end,

			hideCaret = function()
				CARETV = false
			end,

			setCaretColor = function(color)
				CARETCOLOR = color
			end,


			findWindowByTitle = function(title)
				for k, v in pairs(processes) do
					if string.lower(v.title) == string.lower(title) then
						return k
					end
				end
			end,

			findWindowByFileName = function(fname)
				for k, v in pairs(processes) do
					if string.lower(v.fileName) == string.lower(fname) then
						return k
					end
				end
			end,


			loadAPI = os.loadAPI,
			unloadAPI = os.unloadAPI,
			time = os.time,
			clock = os.clock,
			
			getETime = function()
				return ETIME
			end,


			getProcessUsedMemory = function(pid, MAXDEPTH)
				local info

				if pid > 0 then
					info = GetProcessInfo(pid)
				end

				local depth = 0
				local size = 0


				local CHAR_SIZE = 1
				local NUMBER_SIZE = 16
				local POINTER_SIZE = 4
				local BOOLEAN_SIZE = 4

				local MAXDEPTH = MAXDEPTH or 100--128

				local table_sizes = {}
				local strings = {}


				local function getTableSize(t)
					local size = 0

					if table_sizes[t] ~= nil then return 0 else
						if table_sizes[t] == nil then
							for k, v in pairs(t) do
								if type(k) == "string" then
									size = size + 40
								else
									size = size + 16
								end
							end
						end

						if depth <= MAXDEPTH then
							for k, v in pairs(t) do
								if type(v) == "string" then
									if not strings[v] then
										size = size + 17 + string.len(v)
										strings[v] = true
									end
								elseif type(v) == "boolean" then
									size = size + 16
								elseif type(v) == "number" then
									size = size + 16
								elseif type(v) == "table" then
									depth = depth + 1
									if table_sizes[t] == nil then 
										size = size + 40 + getTableSize(v)
									end
									depth = depth - 1
								elseif type(v) == "function" then
									local env = getfenv(v)
									size = size + 20

									if env ~= nil then
										depth = depth + 1
										if table_sizes[t] == nil then 
											size = size + 40 + getTableSize(env)
										end
										depth = depth - 1
									end
								else
									size = size + 16
								end
							end
						end
					end

					table_sizes[t] = size
					return size or 0
				end


				--local env = getfenv(info.program)
				--if env ~= getfenv(0) then
				--	size = getTableSize(env) or 0
				--end
				if pid > 0 then
					getTableSize(getfenv(0))
					getTableSize(getfenv(1))
					local newSize = 0

					for i = 1, 512 do
						newSize = getTableSize(getfenv(info.program))
						size = size + newSize
					end
				else
					for i = 1, 512 do
						size = size + getTableSize(getfenv(0)) + getTableSize(getfenv(1))
					end
				end
				--if info.fullenv ~= nil then
					--size = getTableSize(getfenv())
					--size = getTableSize(info.fullenv)
				--end


				return size
			end,
		},

		widgets = {
			Label = label,
			Button = button,
			Edit = edit,
			ScrollBar = scrollBar,
			Panel = panel,
			ListView = listView,
			PopupMenu = popupMenu,
			MenuBar = menuBar,
			PaintBox = paintBox,
			FileListView = fileListView,
			ListBox = listBox,
			TextArea = textArea,
			SharedDocView = shdocvw,
			GLSurface = glSurface,
			CheckBox = checkbox,
			ProgressBar = progressBar,

			dialogs = {
				OpenDialog = openDialog,
				SaveDialog = saveDialog,
			},

			popupMenu = function(menu, x, y)
				lastMenu = menu
				menu.canvas = screen
				menu:popUp(x, y)
			end,
		},

		config = {
			DESKTOP_COLOR = config.desktop_color,
			PROCESS_TIMER = config.timer,
			AUTORUN = config.autorun,

		},
	}

	if kernelMode == true then
		env.kernel = {}

		env.kernel.kiRegisterEventReceiver = function(event)
			--table.insert(eventHandlers, event, hwnd)
			eventHandlers[event] = hwnd
		end

		env.kernel.kiUnRegisterEventReceiver = function(event)
			--table.remove(eventHandlers, event)
			eventHandlers[event] = nil
		end

		env.kernel.env = getfenv(1)
	end


	if process.legacyMode then
		setfenv(program, legacyEnv)
	else
		setfenv(program, env)
	end
	
	process.thread = coroutine.create(program)
	process.env = { timer = timer }
	process.fullenv = env

	processes[hwnd] = process
	--table.insert(plist, hwnd)
	return hwnd
end


local osPath = ...
function GetOsPath()
	--\[\[if fs.exists(".myospath") then
		file = fs.open(".myospath", "r")
		osPath = file.readAll()
		file.close()

		return osPath
	else
		write("myOs is not found on the main drive. Try reinstalling...")
		os.shutdown()
	end\]\]
	return osPath
end


function SendMessage(hwnd, message)
	table.insert(processes[hwnd].messages, message)
end


function GetMessage(hwnd)
	local result = table.remove(processes[hwnd].messages, 1)

	if result ~= nil then
		if processes[hwnd].iterations > PROCESS_MAX_ITERATIONS then
			processes[hwnd].iterations = 0
			--coroutine.yield()
		end

		processes[hwnd].iterations = processes[hwnd].iterations + 1
		return result
	else
		coroutine.yield()
		return GetMessage(hwnd)
	end
end




function Run(fileName, background, params, kernelMode)
	if params == nil then params = {} end
	params[1] = fileName

	local hwnd = CreateProcess(fileName, params, kernelMode)

	if not (background == false) then
		ACTIVE_PROCESS = hwnd
	end

	SendMessage(hwnd, { msg = "create" })

	return hwnd
end



function LoadConfig()
	if not fs.exists(GetOsPath() .. "/system2/win.ini") then
		local c = {
			autorun = {

			},

			system = 
			{
				timer = 0.1,
				version = "0.9"
			},

			extensions = {
				lnk = "lnkview \"%FILENAME%\"",
			},

			desktop = {
				bgcolor = colors.cyan,
			},
		}

		iniFiles.write(GetOsPath() .. "/system2/win.ini", c)
	end

	local c = iniFiles.read(GetOsPath() .. "/system2/win.ini")
	config.timer = tonumber(c.system.timer)
	config.desktop_color = tonumber(c.desktop.bgcolor)
	config.extensions = c.extensions
	config.autorun = c.autorun
	config.version = c.system.version
end




function Init()
	term.setBackgroundColor(colors.black)
	term.setTextColor(colors.white)
	term.clear()
	term.setCursorPos(1, 1)
	term.setCursorBlink(true)
	sleep(1)


	local oldLoadAPI = os.loadAPI

	os.loadAPI = function(path)
		--if assert(oldLoadAPI(path)) then print(path .. " loaded.") else 
		--	read()
		--	error("Kernel loader failure")
		--end
		if oldLoadAPI(path) then print("\"" .. path .. "\" loaded.") else 
			print("Unable to load \"" .. path .. "\". Press [Enter] to continue...")
			read()
			error("Kernel loader failure")
		end

		--os.sleep(0.001)
	end

	if term.isColor() then
		print("Color terminal found.")
		sleep(0.1)
	else
		error("No color monitor found. Unable to continue.")
	end

	print("loading os components...")
	sleep(0.1)
	print("")

	os.loadAPI(GetOsPath() .. "/system/user")
	os.loadAPI(GetOsPath() .. "/system/application")
	os.loadAPI(GetOsPath() .. "/system/form")
	os.loadAPI(GetOsPath() .. "/system/iniFiles")
	os.loadAPI(GetOsPath() .. "/system/pathutils")
	os.loadAPI(GetOsPath() .. "/system/dialogs")

	os.loadAPI(GetOsPath() .. "/system/widgets/label")
	os.loadAPI(GetOsPath() .. "/system/widgets/button")
	os.loadAPI(GetOsPath() .. "/system/widgets/edit")
	os.loadAPI(GetOsPath() .. "/system/widgets/scrollBar")
	os.loadAPI(GetOsPath() .. "/system/widgets/panel")
	os.loadAPI(GetOsPath() .. "/system/widgets/listView")
	os.loadAPI(GetOsPath() .. "/system/widgets/popupMenu")
	os.loadAPI(GetOsPath() .. "/system/widgets/menuBar")
	os.loadAPI(GetOsPath() .. "/system/widgets/paintBox")
	os.loadAPI(GetOsPath() .. "/system/widgets/fileListView")
	os.loadAPI(GetOsPath() .. "/system/widgets/listBox")
	os.loadAPI(GetOsPath() .. "/system/widgets/textArea")
	os.loadAPI(GetOsPath() .. "/system/widgets/shdocvw")
	os.loadAPI(GetOsPath() .. "/system/widgets/textView")
	os.loadAPI(GetOsPath() .. "/system/widgets/glSurface")
	os.loadAPI(GetOsPath() .. "/system/widgets/checkbox")
	os.loadAPI(GetOsPath() .. "/system/widgets/progressBar")

	os.loadAPI(GetOsPath() .. "/system/commonDialogs/openDialog")
	os.loadAPI(GetOsPath() .. "/system/commonDialogs/saveDialog")

	os.loadAPI = oldLoadAPI
	print("")

	print("loading os config...")
	LoadConfig()
	sleep(0.1)

	print("loading kernel mode drivers...")
	loadDrivers()
	sleep(0.6)
	print("")


	local x, y = term.getSize()
	screen = user.CreateCanvas(x, y)
	screen.autoScroll = false
	screen.showCursor = false

	term.clear()
	term.setCursorBlink(false)
	os.sleep(0.5)
	--screen.effect = user.CreateEffect_Acid()
	--screen.effect = user.CreateEffect_Shadow()


	TASKBAR_PROCESS = Run(GetOsPath() .. "/system2/taskbar.app")

	--Run(GetOsPath() .. "/windowProcess")
	--Run(GetOsPath() .. "/windowProcess")
	DESKTOP_PROCESS = Run(GetOsPath() .. "/system2/desktop.app")
	--Run(GetOsPath() .. "/system2/taskbar.app")
	--Run(GetOsPath() .. "/system2/sysinfo.app")
	--Run(GetOsPath() .. "/system2/paintbrush.app")
	--Run(GetOsPath() .. "/system2/explorer.app")
	Run(GetOsPath() .. "/system2/shldr.app")

	Main()
end



function loadDrivers()
	local drivers = fs.list(GetOsPath() .. "/drivers/")

	for i, v in ipairs(drivers) do
		if (user.stringends(v, ".app")) and (not (fs.isDir(v))) then
			print(GetOsPath() .. "/drivers/" .. v)
			Run(GetOsPath() .. "/drivers/" .. v, nil, nil, true)
		end
	end
end





function ShellRun(name, cmd, path)
	local fileName = user.split(name, "%.")
	local fileExt = fileName[#fileName]


	if name == "shutdown" then
		running = false
	else
		if (fileExt == "app") or (#fileName == 1) then
			for i, v in ipairs(path) do
				if (fs.exists(getPath(v) .. "/" .. name) and (fileExt == "app")) or fs.exists(getPath(v) .. "/" .. name .. ".app") then
					if #fileName == 1 then
						Run(getPath(v) .. "/" .. name .. ".app", true, cmd)
					else
						Run(getPath(v) .. "/" .. name, true, cmd)
					end
					break
				end
			end
		else
			if config.extensions[fileExt] ~= nil then
				for i, v in ipairs(path) do
					if fs.exists(getPath(v) .. name) then
						Shell(string.gsub(config.extensions[fileExt], "%%FILENAME%%", v .. name))
						break
					end
				end
			end
		end
	end
end





function drawTaskbar()
	--screen:fillrect(1, screen.size.y, screen.size.x, 1, colors.lightGray)
	if TASKBAR_PROCESS > 0 then
		screen:draw(0, screen.size.y - 1, processes[TASKBAR_PROCESS].canvas)
	end
end


function drawMessage(message)
	--{ uType = uType, text = text, caption = caption, buttons = buttons, defText = defText }
	--local msgBox = dialogs.MessageBoxCreate(message, screen)
	message:refresh()
end




function Main()
	local timerId = os.startTimer(config.timer)
	local DestroyList = {}
	local destroy = {}


	--setmetatable(destroy, DestroyList)
	--DestroyList.__mode = "v"

	while running do
		local event, key, x, y, p2 = os.pullEventRaw()
		if (event == "timer") and (key == timerId) then
			local ostime = os.clock()

			if ACTIVE_PROCESS == TASKBAR_PROCESS then
				ACTIVE_PROCESS = 0
			end

			--print("")

			for hwnd, process in pairs(processes) do
				--print(hwnd, " ", coroutine.status(process.thread))
				local time = os.clock()
				

				if (not process.suspended) and (coroutine.status(process.thread) ~= "dead") then
					CURRENT_PROCESS = hwnd

					if process.env.timer.enabled then
						process.env.timer.value = process.env.timer.value + config.timer

						if process.env.timer.value > process.env.timer.interval then
							process.env.timer.value = 0
							if process.env.timer.onTimer ~= nil then process.env.timer.onTimer() end
						end
					end



					--run()
					--assert(run())

					
					--assert(coroutine.resume(process.thread))
					--process.etime = time - os.time()

					process.iterations = 0
					local status, message = pcall(function() assert(coroutine.resume(process.thread)) end)

					if not status then
						local text = message

						if string.len(text) > screen.size.x - 8 then
							local t1 = string.sub(text, 1, screen.size.x - 8)
							local t2 = string.sub(text, screen.size.x - 7)
							text = t1 .. "-\n" .. t2

							--\[\[text = ""
							local s = user.split(text, " ")
							local str = ""
							local i = 0

							for j = 1, #s do
								str = ""

								repeat
									i = i + 1
									str = str .. s[i]
								until string.len(str) > screen.size.x - 8

								text = text .. str .. "\n"
							end\]\]
						end


						processes[TASKBAR_PROCESS].message = 
								dialogs.MessageBoxCreate({ uType = "message", 
									text = text .. ";", 
									caption = pathutils.extractFileName(process.fileName),
									buttons = { { caption = "OK", onClick = function(sender) 
										processes[TASKBAR_PROCESS].message = nil
										processes[ACTIVE_PROCESS].canvas.effect = nil
									end } }, 
									defText = "" }, 
								screen, button)
						processes[TASKBAR_PROCESS].message.width = screen.size.x - 4
					end
				end

				process.etime = time - os.clock()

				if (coroutine.status(process.thread) == "dead") or (process.kill ~= nil) then
					table.insert(destroy, hwnd)
					if ACTIVE_PROCESS == hwnd then ACTIVE_PROCESS = DESKTOP_PROCESS end
				end
			end

			screen:clear()
			--drawTaskbar()

			if ACTIVE_PROCESS > 0 then
				if processes[ACTIVE_PROCESS].canvas ~= nil then
					if processes[ACTIVE_PROCESS].message ~= nil then
						processes[ACTIVE_PROCESS].canvas.effect = user.CreateEffect_Shadow()
						screen:draw(0, screen.size.y - processes[ACTIVE_PROCESS].canvas.size.y - 1, processes[ACTIVE_PROCESS].canvas, true)
						drawMessage(processes[ACTIVE_PROCESS].message)
					else
						screen:draw(0, screen.size.y - processes[ACTIVE_PROCESS].canvas.size.y - 1, processes[ACTIVE_PROCESS].canvas, true)
					end
					--term.setCursorPos(processes[ACTIVE_PROCESS].canvas.cursorPos.x, processes[ACTIVE_PROCESS].canvas.cursorPos.y)
				end
			end

			if lastMenu ~= nil then
				lastMenu:refresh()
			end

			drawTaskbar()

			if processes[TASKBAR_PROCESS].message ~= nil then
				processes[ACTIVE_PROCESS].canvas.effect = user.CreateEffect_Shadow()
				--screen:draw(0, screen.size.y - processes[TASKBAR_PROCESS].canvas.size.y - 1, processes[TASKBAR_PROCESS].canvas, true)
				drawMessage(processes[TASKBAR_PROCESS].message)
			end

			screen:render(0, 0)

			term.setCursorPos(CARETX, CARETY)
			term.setTextColor(CARETCOLOR)
			term.setCursorBlink(CARETV)

			if ACTIVE_PROCESS > 0 then
				--processes[ACTIVE_PROCESS].fullenv.legacyEnv.term.redraw()
				processes[ACTIVE_PROCESS].fullenv.legacyEnv.term.restoreCursor()
			end


			local x, y = term.getCursorPos()
			--term.setCursorPos(x, y + screen.size.y - processes[ACTIVE_PROCESS].canvas.size.y - 1)
			--screen:render(0, 0)


			for i, k in ipairs(destroy) do
				local process = k
				processes[k] = nil
			end

			destroy = {}


			if NEW_ACTIVE_PROCESS ~= 0 then
				table.insert(activeProcesses, ACTIVE_PROCESS)
				ACTIVE_PROCESS = NEW_ACTIVE_PROCESS
				NEW_ACTIVE_PROCESS = 0

				if ACTIVE_PROCESS < 0 then ACTIVE_PROCESS = DESKTOP_PROCESS end
			end


			ETIME = os.clock() - ostime
			timerId = os.startTimer(config.timer)
		else
			if event == "terminate" then
				Shell("procman.app")
				event = "refresh"
			end

			if (event == "key") or (event == "char") or (event == "mouse_click") or (event == "mouse_drag") then
				if ACTIVE_PROCESS > 0 then
					local char = ""
					if event == "char" then char = key end

					if (not ((event == "mouse_click") and (lastMenu ~= nil))) and processes[ACTIVE_PROCESS].message == nil then
						SendMessage(ACTIVE_PROCESS, { msg = event, key = key, char = char, button = key, x = x, y = y, n = y })
					else
						if processes[ACTIVE_PROCESS].message ~= nil then
							if event == "mouse_click" then
								if processes[ACTIVE_PROCESS].message.mouseClick ~= nil then
									processes[ACTIVE_PROCESS].message:mouseClick(key, x, y)
								end
							end

							if (event == "char") or (event == "key") then
								if processes[ACTIVE_PROCESS].message.keyPress ~= nil then
									char = key
									if event == "key" then char = "" end
									processes[ACTIVE_PROCESS].message:keyPress(key, char)
								end
							end
						end
					end
				end

				if TASKBAR_PROCESS > 0 then
					local char = ""
					if event == "char" then char = key end

					if not (type(y) == "number") then y = 0 end
					SendMessage(TASKBAR_PROCESS, { msg = event, key = key, char = char, button = key, x = x, y = y - screen.size.y + 1, n = y })

					if processes[TASKBAR_PROCESS].message ~= nil then
						if event == "mouse_click" then
							if processes[TASKBAR_PROCESS].message.mouseClick ~= nil then
								processes[TASKBAR_PROCESS].message:mouseClick(key, x, y)
							end
						end

						if event == "char" then
							if processes[TASKBAR_PROCESS].message.keyPress ~= nil then
								char = key
								processes[TASKBAR_PROCESS].message:keyPress(key, char)
							end
						end
					end
				end


				if event == "mouse_click" then
					if lastMenu ~= nil then
						lastMenu:mouseClick(button, x, y)
						if not lastMenu.showing then lastMenu = nil end
					end
				end
			else
				--error(event .. " " .. key)
				SendMessage(ACTIVE_PROCESS, {event, key, x, y, p2})
			end


			for k, v in pairs(eventHandlers) do
				if event == k then
					SendMessage(v, {msg = event, arg1 = key, arg2 = x, arg3 = y, arg4 = p2})
				end
			end

			--if (event == "http_failure") or (event == "http_success") then
			--	error(event .. " " .. key)
			--end

		end
	end

	Shutdown()
end



function Shutdown()
	term.setBackgroundColor(colors.black)
	term.clear()
	term.setCursorPos(1, 1)
end











function Load()
	term.clear()
	local status, err = pcall(Init)

	if not status then
		term.setBackgroundColor(colors.blue)
		term.setTextColor(colors.white)
		term.clear()
		term.setCursorPos(1, 1)

		local t = {}
		local i = 0

		for token in string.gmatch(err, "(%w+):(%w+)") do
			table.insert(t, token)
			i = i + 1
		end

		local moduleName = t[1]

		print("An error has occured.")
		print("")
		print("Module \"" .. moduleName .. "\" generated an unexpected exception and is unable to continue. " ..
			"If this is the first time you have seen this error, restart your computer. Otherwise, contact software developer " ..
			"or server administrator for more details regarding this error.")
		print("")
		print("Technical information:")
		print("")
		print(err)
		print("")
		print("")
		print("Press [Enter] to reboot.")

		read()
		os.reboot()
		--Load()
	end
end



Load()]])
table.insert(names, "/license.txt")
table.insert(values, [[
CCWin - Terms and conditions

1.    Preamble: This Agreement, signed on Jun 4, 2015 (hereinafter: Effective Date) governs the relationship between User, a Business Entity, (hereinafter: Licensee) and Puzzletime, a private person whose principal place of business is Moscow, Russian Federation (hereinafter: Licensor). This Agreement sets the terms, rights, restrictions and obligations on using CCWin (hereinafter: The Software) created and owned by Licensor, as detailed herein

2.    License Grant: Licensor hereby grants Licensee a Sublicensable, Non-assignable & non-transferable, Pepetual, Non-commercial, Including the rights to distribute derivative works, Non-exclusive license, all with accordance with the terms set forth and other legal restrictions set forth in 3rd party software used while running Software.

    2.1    Limited: Licensee may use Software for the purpose of:
        2.1.1    Running Software on Licensee’s Website[s] and Server[s];
        2.1.2    Allowing 3rd Parties to run Software on Licensee’s Website[s] and Server[s];
        2.1.3    Publishing Software’s output to Licensee and 3rd Parties;
        2.1.4    Distribute verbatim copies of Software’s output (including compiled binaries);
        2.1.5    Modify Software to suit Licensee’s needs and specifications.
    2.2    This license is granted perpetually, as long as you do not materially breach it.

    2.3    Non Assignable & Non-Transferable: Licensee may not assign or transfer his rights and duties under this license.

    2.4    Non-Commercial: Licensee may not use Software for commercial purposes. for the purpose of this license, commercial purposes means that a 3rd party has to pay in order to access Software or that the Website that runs Software is behind a paywall.

    2.5    Including the right to Distribute Derivative Works: Licensee may create and distribute derivative works based on Software, including amending Software’s source code, modifying it, integrating it into a larger work or removing portions of Software, as long as credit to the Licensor is granted and that redistribution is made under the terms of this license.

    2.6    With Attribution Requirements﻿: Mentioning in the "About" screen (and in documentation, if present)

    2.7    [Multi-]Site: Licensee may use Software on unlimited server[s] and unlimited website[s], for Licensee’s websites only 
3.    Term & Termination: The Term of this license shall be until terminated. Licensor may terminate this Agreement, including Licensee’s license in the case where Licensee :

    3.1    became insolvent or otherwise entered into any liquidation process; or

    3.2    exported The Software to any jurisdiction where licensor may not enforce his rights under this agreements in; or

    3.3    Licensee was in breach of any of this license's terms and conditions and such breach was not cured, immediately upon notification; or

    3.4    Licensee in breach of any of the terms of clause 2 to this license; or

    3.5    Licensee otherwise entered into any arrangement which caused Licensor to be unable to enforce his rights under this License.
4.    Payment: In consideration of the License granted under clause 2, Licensee shall pay Licensor a fee, via Credit-Card, PayPal or any other mean which Licensor may deem adequate. Failure to perform payment shall construe as material breach of this Agreement.

5.    Upgrades, Updates and Fixes: Licensor may provide Licensee, from time to time, with Upgrades, Updates or Fixes, as detailed herein and according to his sole discretion. Licensee hereby warrants to keep The Software up-to-date and install all relevant updates and fixes, and may, at his sole discretion, purchase upgrades, according to the rates set by Licensor. Licensor shall provide any update or Fix free of charge; however, nothing in this Agreement shall require Licensor to provide Updates or Fixes.

    5.1    Upgrades: for the purpose of this license, an Upgrade shall be a material amendment in The Software, which contains new features and or major performance improvements and shall be marked as a new version number. For example, should Licensee purchase The Software under version 1.X.X, an upgrade shall commence under number 2.0.0.

    5.2    Updates: for the purpose of this license, an update shall be a minor amendment in The Software, which may contain new features or minor improvements and shall be marked as a new sub-version number. For example, should Licensee purchase The Software under version 1.1.X, an upgrade shall commence under number 1.2.0.

    5.3    Fix: for the purpose of this license, a fix shall be a minor amendment in The Software, intended to remove bugs or alter minor features which impair the The Software's functionality. A fix shall be marked as a new sub-sub-version number. For example, should Licensee purchase Software under version 1.1.1, an upgrade shall commence under number 1.1.2.

6.    Support: Software is provided under an AS-IS basis and without any support, updates or maintenance. Nothing in this Agreement shall require Licensor to provide Licensee with support or fixes to any bug, failure, mis-performance or other defect in The Software.

    6.1    Bug Notification: Licensee may provide Licensor of details regarding any bug, defect or failure in The Software promptly and with no delay from such event; Licensee shall comply with Licensor's request for information regarding bugs, defects or failures and furnish him with information, screenshots and try to reproduce such bugs, defects or failures.

    6.2    Feature Request: Licensee may request additional features in Software, provided, however, that (i) Licensee shall waive any claim or right in such feature should feature be developed by Licensor; (ii) Licensee shall be prohibited from developing the feature, or disclose such feature request, or feature, to any 3rd party directly competing with Licensor or any 3rd party which may be, following the development of such feature, in direct competition with Licensor; (iii) Licensee warrants that feature does not infringe any 3rd party patent, trademark, trade-secret or any other intellectual property right; and (iv) Licensee developed, envisioned or created the feature solely by himself.

7.    Liability:  To the extent permitted under Law, The Software is provided under an AS-IS basis. Licensor shall never, and without any limit, be liable for any damage, cost, expense or any other payment incurred by Licensee as a result of Software’s actions, failure, bugs and/or any other interaction between The Software  and Licensee’s end-equipment, computers, other software or any 3rd party, end-equipment, computer or services.  Moreover, Licensor shall never be liable for any defect in source code written by Licensee when relying on The Software or using The Software’s source code.

8.    Warranty:  

    8.1    Intellectual Property: Licensor hereby warrants that The Software does not violate or infringe any 3rd party claims in regards to intellectual property, patents and/or trademarks and that to the best of its knowledge no legal action has been taken against it for any infringement or violation of any 3rd party intellectual property rights.

    8.2    No-Warranty: The Software is provided without any warranty; Licensor hereby disclaims any warranty that The Software shall be error free, without defects or code which may cause damage to Licensee’s computers or to Licensee, and that Software shall be functional. Licensee shall be solely liable to any damage, defect or loss incurred as a result of operating software and undertake the risks contained in running The Software on License’s Server[s] and Website[s].

    8.3    Prior Inspection: Licensee hereby states that he inspected The Software thoroughly and found it satisfactory and adequate to his needs, that it does not interfere with his regular operation and that it does meet the standards and scope of his computer systems and architecture. Licensee found that The Software interacts with his development, website and server environment and that it does not infringe any of End User License Agreement of any software Licensee may use in performing his services. Licensee hereby waives any claims regarding The Software's incompatibility, performance, results and features, and warrants that he inspected the The Software.

9.    No Refunds: Licensee warrants that he inspected The Software according to clause 7(c) and that it is adequate to his needs. Accordingly, as The Software is intangible goods, Licensee shall not be, ever, entitled to any refund, rebate, compensation or restitution for any reason whatsoever, even if The Software contains material flaws.

10.    Indemnification: Licensee hereby warrants to hold Licensor harmless and indemnify Licensor for any lawsuit brought against it in regards to Licensee’s use of The Software in means that violate, breach or otherwise circumvent this license, Licensor's intellectual property rights or Licensor's title in The Software. Licensor shall promptly notify Licensee in case of such legal action and request Licensee’s consent prior to any settlement in relation to such lawsuit or claim.

11.    Governing Law, Jurisdiction: Licensee hereby agrees not to initiate class-action lawsuits against Licensor in relation to this license and to compensate Licensor for any legal fees, cost or attorney fees should any claim brought by Licensee against Licensor be denied, in part or in full. 
]])
table.insert(names, "/locale/EN-US/setup.ini")
table.insert(values, [[[locale]
1 = Next
2 = Back
3 = Welcome to the setup wizard for %APPNAME% %VERSION%.
4 = This utility will help you to install
5 = %APPNAME% %VERSION% on your computer.
6 = To proceed, click "Next".
7 = Cancel
8 = Cancel the installation?
9 = Cancel
10 = Yes
11 = No
12 = I%BLINDLY%accept the license agreement
13 = To proceed, you must accept this.
14 = Error
15 = Ok
16 = Installation path:
17 = Everything is ready for the installation.
18 = To proceed, click "Next".
19 = Please, close all other applications
20 = before continuing.
21 = Preparing for install...
22 = Copying files...
23 = Creating shortcuts...
24 = Installation complete.
25 = To exit this wizard, click "Finish"
26 = Finish
27 = Run the installed application.
28 = View Readme file.
29 = Creating shortcuts...]])
table.insert(names, "/logo.pic")
table.insert(values, [[pic|7|32|b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=30 00 00 30 b9=30 00 00 30 30 00 30 b9=b9=30 b9=b9=30 00 30 00 30 00 00 30 b9=00 b9=b9=b9=b9=30 00 30 30 00 30 00 30 30 00 30 30 00 30 30 00 30 30 00 30 30 00 30 00 00 30 30 00 30 b9=b9=b9=30 00 30 30 30 30 00 30 30 30 30 30 00 30 00 30 00 30 00 30 30 00 30 00 30 00 30 00 30 b9=b9=b9=30 00 30 30 00 30 00 30 30 00 30 30 00 30 00 30 00 30 00 30 30 00 30 00 30 00 30 00 30 b9=b9=b9=b9=30 00 00 30 b9=30 00 00 30 b9=b9=30 00 30 b9=30 00 30 b9=30 00 30 00 b9=30 00 00 b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=b9=]])
table.insert(names, "/system/application")
table.insert(values, [[

function Create(processInfo, _os)
	local _canvas = processInfo.canvas
	local _hwnd = processInfo.hwnd
	_canvas.autoScroll = false

	--return canvas

	local result = {
		hwnd = _hwnd,
		canvas = _canvas,
		os = _os,
		forms = { },
		activeForm = nil,
		running = true,
		info = processInfo,
		ctrlCount = 0,
		threads = {},


		run = function(self)
			while self.running do
				if self.ctrlCount > 0 then self.ctrlCount = self.ctrlCount - 0.1 end
				if self.ctrlCount < 0 then self.ctrlCount = 0 end
				
				local threadsRemoval = {}

				for k, v in pairs(self.threads) do
					if v ~= nil then
						if coroutine.status(v) == "suspended" then
							status, err = coroutine.resume(v)
							if not status then
								error(tostring(err))
							end
						else
							table.insert(threadsRemoval, k)
						end
					end
				end

				local threads = {}
				for k, v in pairs(threadsRemoval) do
					self.threads[k] = nil
				end
				for k, v in pairs(self.threads) do
					if v ~= nil then
						table.insert(threads, v)
					end
				end
				self.threads = threads
				local message = self.os.getMessage(self.hwnd)

				if message ~= nil then
					if self.activeForm ~= nil then
						if (message.msg == "key") or (message.msg == "char") then
							if self.activeForm.keyPress ~= nil then
								self.activeForm:keyPress(message.key, message.char)
							end

							if (message.key == 29) or (message.key == 157) then
								self.ctrlCount = 1
							end
						end

						if message.msg == "mouse_click" then
							if self.activeForm.mouseClick ~= nil then
								self.activeForm:mouseClick(message.button, message.x, message.y)
							end
						end

						if message.msg == "mouse_drag" then
							if self.activeForm.mouseDrag ~= nil then
								self.activeForm:mouseDrag(message.button, message.x, message.y)
							end
						end

						if self.activeForm.onMessage ~= nil then
							self.activeForm:onMessage(message)
						end

						if (self.os.getActiveProcess() == self.hwnd) or (message.msg == "create") or (message.msg == "refresh") then
							self.os.hideCaret()
							self.activeForm:refresh()
						end
					end
				end
			end

			self.os.hideCaret()
		end,


		addForm = function(self, form, name)
			self.forms[name] = form
			form.parent = self
			form.name = name
		end,


		terminate = function(self)
			self.running = false
			self.canvas.cursorBlink = false
			self.os.hideCaret()
			self.os.sendMessage(self.hwnd, { msg = "refresh" })
		end,


		showMessage = function(self, message)
			self.os.messageBox("message", message, self.activeForm.name, {{ caption = "OK", onClick = function(sender) self.os.hideMessageBox() end }}, "defText")
		end,


		isCtrlDown = function(self)
			if self.ctrlCount > 0 then return true else return false end
		end,


		createThread = function(self, proc)
			if type(proc) ~= "function" then
				return false
			end
			table.insert(self.threads, coroutine.create(proc))
			return true
		end,
	}

	return result
end


function Create2()
	return "Success."
end]])
table.insert(names, "/system/commonDialogs/openDialog")
table.insert(values, [[
function Create(_parent, name)
	local dialog = {
		parent = _parent,
		left = 0,
		top = 0, 
		height = 0,
		width = 0,
		focused = false,
		visible = true,
		dialogForm = nil,
		title = "Open File...",
		initialDir = "home:/",
		lastActiveForm = nil,
		fileName = nil,
		onExecute = nil,
		dirOnly = false,


		refresh = function(self)
			if self.dialogForm ~= nil then
				self.dialogForm.parent = self.parent.parent
				self.dialogForm:refresh()
			end
		end,


		execute = function(self)
			self.lastActiveForm = self.parent.parent.activeForm

			self.dialogForm = form.Create("CommonDialogForm")
			self.dialogForm.parent = self.parent.parent
			self.parent.parent:addForm(self.dialogForm, "CommonDialogForm")
			self.dialogForm:show()

			self.dialogForm.name = self.title
			self.dialogForm.controlBox = false
			self.dialogForm.bgcolor = colors.white


			local listView = fileListView.Create(self.dialogForm, "listView")
			listView.bgcolor = colors.white
			listView.top = 1 + 3
			listView.left = 1
			listView.width = self.parent.parent.canvas.size.x
			listView.height = self.parent.parent.canvas.size.y - 1 - 3   - 3
			listView.lastTime = 0

			listView.path = self.initialDir
			listView.dirOnly = self.dirOnly
			listView:refreshList()


			self.parent.parent.os.sendMessage(self.parent.parent.hwnd, { msg = "refresh" })

			listView.onClick = function(sender)
				local time = os.time()

				if #sender.selectedList > 0 then
					sender.parent.widgets["Panel2"].widgets["FileName"].text = sender.list[sender.selectedList[1\]\].name
					sender.parent.widgets["Panel2"].widgets["FileName"]:refresh()
				end

				if (time - sender.lastTime) * 10 < 0.1 then
					local selected = listView.selectedList
					if #selected > 0 then
						listView:navigate(listView.list[selected[1\]\].name, true, self.parent.parent.os)
						listView.selectedList = {}
						sender.parent.widgets["Panel2"].widgets["FileName"].text = ""
					end
				end

				sender.lastTime = time
			end

			listView.onNavigate = function(sender, path)
				sender.parent.widgets["Panel"].widgets["AddressBar"].text = path
				sender.selectedList = {}
			end



			local panel1 = panel.Create(self.dialogForm, "Panel")
			panel1.top = 1
			panel1.left = 0
			panel1.width = self.parent.parent.canvas.size.x
			panel1.height = 3
			panel1.bgcolor = colors.lightGray


			local panel2 = panel.Create(self.dialogForm, "Panel2")
			panel2.top = 1 + panel1.height + listView.height
			panel2.left = 0
			panel2.width = self.parent.parent.canvas.size.x
			panel2.height = 3
			panel2.bgcolor = colors.lightGray


			local fnLabel = label.Create(panel2, "FnLabel")
			fnLabel.left = 2
			fnLabel.top = 2
			fnLabel.height = 1
			fnLabel.align = "left"
			fnLabel.caption = "File Name:"
			fnLabel.width = string.len(fnLabel.caption) + 1

			local fileName = edit.Create(panel2, "FileName")
			fileName.left = fnLabel.left + fnLabel.width
			fileName.top = 2
			fileName.height = 1
			fileName.width = self.parent.parent.canvas.size.x - fileName.left - 16 - 2
			fileName.text = ""

			--fileName.onRefresh = function(sender)
				--sender.text = string.gsub(sender.text, "%/%/", "%/")
				--if #listView.selectedList > 0 then
					--sender.text = listView.list[listView.selectedList[1\]\].name
				--else
					--sender.text = ""
				--end
			--end


			local openButton = button.Create(panel2, "OpenButton")
			openButton.left = fileName.left + fileName.width + 1
			openButton.top = 2
			openButton.height = 1
			openButton.width = 8
			--openButton.forecolor2 = colors.white
			openButton.align = "center"
			openButton.caption = " Open"

			openButton.onClick = function(sender)
				local fn = sender.parent.parent.widgets["Panel"].widgets["AddressBar"].text .. "/" .. fileName.text
				fn = string.gsub(fn, "//", "/")
				fn = string.gsub(fn, "home:/", "", 1)

				if (fs.exists(fn) and (not fs.isDir(fn))) or (fs.exists(fn) and self.dirOnly) then
					self.fileName = "home:/" .. fn
					self.dialogForm = nil
					self.lastActiveForm.parent.forms["CommonDialogForm"] = nil
					self.lastActiveForm:show()
					--self.lastActiveForm.parent.activeForm = self.lastActiveForm
					self.parent.parent.os.sendMessage(self.parent.parent.hwnd, { msg = "refresh" })

					if self.onExecute ~= nil then
						self:onExecute()
					end
				else
					local os2 = sender.parent.parent.parent.os
					os2.messageBox("message", "This file does not exist!\nPlease select another file.", "Warning", 
						{ 
							{caption = "OK", onClick = function(sender) os2.hideMessageBox() end } 
						}, "defText")
				end
			end


			local cancelButton = button.Create(panel2, "CancelButton")
			cancelButton.left = openButton.left + openButton.width + 1
			cancelButton.top = 2
			cancelButton.height = 1
			cancelButton.width = 8
			--openButton.forecolor2 = colors.white
			cancelButton.align = "center"
			cancelButton.caption = " Cancel"

			cancelButton.onClick = function(sender)
				self.fileName = nil
				--self.parent.parent.forms["OpenDialogForm"] = nil
				self.dialogForm = nil
				self.lastActiveForm:show()
			end



			local backButton = button.Create(panel1, "BackButton")
			backButton.left = 2
			backButton.top = 2
			backButton.height = 1
			backButton.width = 9
			backButton.forecolor2 = colors.white
			backButton.align = "center"
			backButton.caption = " <- Back"

			backButton.onClick = function(sender)
				listView:goBack()
			end


			local addressBar = edit.Create(panel1, "AddressBar")
			addressBar.left = 2 + 9 + 1
			addressBar.top = 2
			addressBar.height = 1
			addressBar.width = self.parent.parent.canvas.size.x - 2 - 9 - 1 - 5
			addressBar.text = self.initialDir

			addressBar.onRefresh = function(sender)
				sender.text = string.gsub(sender.text, "%/%/", "%/")
			end



			local goButton = button.Create(panel1, "GoButton")
			goButton.left = 2 + 9 + 1 + addressBar.width + 1
			goButton.top = 2
			goButton.height = 1
			goButton.width = 4
			goButton.forecolor2 = colors.white
			goButton.align = "center"
			goButton.caption = " Go"

			goButton.onClick = function(sender)
				if addressBar.text:find("home:/") then
					listView:navigate(addressBar.text)
				else
					listView:navigate("home:/" .. addressBar.text)
				end
			end
		end,
	}

	_parent.widgets[name] = dialog
	_parent.lastZOrder = _parent.lastZOrder + 1
	dialog.zOrder = _parent.lastZOrder
	return dialog
end]])
table.insert(names, "/system/commonDialogs/saveDialog")
table.insert(values, [[
function Create(_parent, name)
	local saveDialog = openDialog.Create(_parent, name)

	saveDialog.title = "Save As..."
	saveDialog.oldExecute = saveDialog.execute

	saveDialog.execute = function(self)
		self:oldExecute()

		self.dialogForm.widgets["Panel2"].widgets["OpenButton"].caption = " Save"

		self.dialogForm.widgets["Panel2"].widgets["OpenButton"].onClick = function(sender)
			local fn = sender.parent.parent.widgets["Panel"].widgets["AddressBar"].text .. "/" .. 
				sender.parent.parent.widgets["Panel2"].widgets["FileName"].text
			fn = string.gsub(fn, "//", "/")
			fn = string.gsub(fn, "home:/", "", 1)


			if fs.exists(fn) and (not fs.isDir(fn)) then
				local os2 = sender.parent.parent.parent.os
				os2.messageBox("message", "This file already exists.\nOverride?", "Warning", 
					{ 
						{caption = "Yes", onClick = function(sender2) 
							os2.hideMessageBox()

							self.fileName = "home:/" .. fn
							self.dialogForm = nil
							self.lastActiveForm.parent.forms["CommonDialogForm"] = nil
							self.lastActiveForm:show()
							--self.lastActiveForm.parent.activeForm = self.lastActiveForm

							self.parent.parent.os.sendMessage(self.parent.parent.hwnd, { msg = "refresh" })

							if self.onExecute ~= nil then
								self:onExecute()
							end
						end },
						{caption = "No", onClick = function(sender) os2.hideMessageBox() end } 
					}, "defText")
			else
				if fs.isDir(fn) then
					self.dialogForm.widgets["listView"]:navigate("home:/" .. fn)
				else
					self.fileName = "home:/" .. fn
					self.dialogForm = nil
					self.lastActiveForm:show()
					--self.lastActiveForm.parent.activeForm = self.lastActiveForm

					if self.onExecute ~= nil then
						self:onExecute()
					end

					self.parent.parent.os.sendMessage(self.parent.parent.hwnd, { msg = "refresh" })
				end
			end
		end
	end

	--kiMain.c -o kiMain.bin -Wl,--subsystem,native


	return saveDialog
end]])
table.insert(names, "/system/dialogs")
table.insert(values, [[
function MessageBoxCreate(message, canvas, buttons)
	local messageBox = {
		message = message,
		canvas = canvas,
		height = 8,
		width = 32,
		widgets = {},
		buttonsLib = buttons,
		parent = {
			canvas = canvas
		},
		lastZOrder = 0,
		focusedWidget = nil,


		refresh = function(self)
			if self.canvas ~= nil then
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 1, math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2) + 1, 
					self.width, self.height, colors.black)
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2), math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2), 
					self.width, self.height, colors.blue)
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 1, math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2) + 1, 
					self.width - 2, self.height - 2, colors.lightGray)

				self.canvas.bgcolor = colors.lightGray
				self.canvas.forecolor = colors.black

				local texts = user.split(self.message.text, "\n")

				for i, v in ipairs(texts) do
					if i <= 3 then
						self.canvas:setCursorPos(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 2, math.floor(self.canvas.size.y / 2)  -
							math.floor(self.height / 2) + 1 + i)
						local str = v

						if string.len(str) > self.width - 3 then
							str = string.sub(str, 1, self.width - 5) .. ".."
						end

						self.canvas:write(str)
					end
				end


				local caption = self.message.caption
				if string.len(caption) > self.width then
					caption = string.sub(caption, 1, self.width - 2) .. ".."
				end

				self.canvas:setCursorPos(math.floor(self.canvas.size.x / 2) - math.floor(string.len(caption) / 2), math.floor(self.canvas.size.y / 2)  -
					math.floor(self.height / 2))
				self.canvas.bgcolor = colors.blue
				self.canvas.forecolor = colors.white
				self.canvas:write(caption)


				if self.message.buttons ~= nil then
					self.widgets = {}
					local width = -1

					if #self.message.buttons > 1 then
						for i, v in ipairs(self.message.buttons) do
							local w = self.buttonsLib.Create(self, i)
							w.width = 9
							w.left = math.floor(self.canvas.size.x / 2) - --\[\[math.floor(w.width / 2) -\]\] width
							width = width + w.width + 1
							w.top = math.floor(self.canvas.size.y / 2) - math.floor(self.height / 2) + self.height - 3
							w.height = 1
							w.caption = v.caption
							w.onClick = v.onClick
						end
					else
						local v = self.message.buttons[1]
						local w = self.buttonsLib.Create(self, 1)
						w.width = 9
						w.left = math.floor(self.canvas.size.x / 2) - math.floor(w.width / 2)
						w.top = math.floor(self.canvas.size.y / 2) - math.floor(self.height / 2) + self.height - 3
						w.height = 1
						w.caption = v.caption
						w.onClick = v.onClick
					end

					self.message.buttons = nil
				end

				if self.widgets ~= nil then
					for i, v in ipairs(self.widgets) do
						v:refresh()
					end
				end
			end
		end,

		mouseClick = function(self, button, x, y)
			if self.widgets ~= nil then
				for i, widget in ipairs(self.widgets) do
					if (x >= widget.left) and (x < widget.left + widget.width) and 
					   (y > widget.top) and (y <= widget.top + widget.height) then
						self.focusedWidget = widget

						if button == 1 then
							if widget.onClick ~= nil then
								widget:onClick()
							end
						else
							if widget.onPopup ~= nil then
								widget:onPopup()
							end
						end

						if widget.onMouseClick ~= nil then
							widget:onMouseClick(button, x, y)
						end

						if widget.mouseClick ~= nil then
							widget:mouseClick(button, x, y)
						end
					end
				end
			end
		end,


		getCanvas = function(self)
			return self.canvas
		end
	}


	return messageBox
end








function InputBoxCreate(message, canvas, buttons)
	local messageBox = {
		message = message,
		canvas = canvas,
		height = 8,
		width = 32,
		widgets = {},
		buttonsLib = buttons,
		parent = {
			canvas = canvas
		},
		lastZOrder = 0,
		focusedWidget = nil,


		refresh = function(self)
			if self.canvas ~= nil then
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 1, math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2) + 1, 
					self.width, self.height, colors.black)
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2), math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2), 
					self.width, self.height, colors.blue)
				self.canvas:fillrect(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 1, math.floor(self.canvas.size.y / 2)  - math.floor(self.height / 2) + 1, 
					self.width - 2, self.height - 2, colors.lightGray)

				self.canvas.bgcolor = colors.lightGray
				self.canvas.forecolor = colors.black


				self.canvas:setCursorPos(math.floor(self.canvas.size.x / 2) - math.floor(self.width / 2) + 2, math.floor(self.canvas.size.y / 2)  -
							math.floor(self.height / 2) + 2)
				self.canvas:write(self.message.text)


				if self.widgets.edit == nil then
					self.widgets.edit = edit.Create(self, "edit")
					self.widgets.edit.left = math.floor((self.canvas.size.x / 2) - (self.width / 2)) + 2
					self.widgets.edit.width = self.width - 3
					self.widgets.edit.top = math.floor(self.canvas.size.y / 2) -
							math.floor(self.height / 2) + 3
					self.widgets.edit.text = self.message.defText
				end

				self.widgets.edit:refresh()
				self.widgets.edit.focused = true
				self.focutedWidget = self.widgets.edit


				local caption = self.message.caption
				if string.len(caption) > self.width then
					caption = string.sub(caption, 1, self.width - 2) .. ".."
				end

				self.canvas:setCursorPos(math.floor(self.canvas.size.x / 2) - math.floor(string.len(caption) / 2), math.floor(self.canvas.size.y / 2)  -
					math.floor(self.height / 2))
				self.canvas.bgcolor = colors.blue
				self.canvas.forecolor = colors.white
				self.canvas:write(caption)


				if self.message.buttons ~= nil then
					self.widgets = {}
					local width = -1

					if #self.message.buttons > 1 then
						for i, v in ipairs(self.message.buttons) do
							local w = self.buttonsLib.Create(self, i)
							w.width = 9
							w.left = math.floor(self.canvas.size.x / 2) - --\[\[math.floor(w.width / 2) -\]\] width
							width = width + w.width + 1
							w.top = math.floor(self.canvas.size.y / 2) - math.floor(self.height / 2) + self.height - 3
							w.height = 1
							w.caption = v.caption
							w.onClick = v.onClick
						end
					else
						local v = self.message.buttons[1]
						local w = self.buttonsLib.Create(self, 1)
						w.width = 9
						w.left = math.floor(self.canvas.size.x / 2) - math.floor(w.width / 2)
						w.top = math.floor(self.canvas.size.y / 2) - math.floor(self.height / 2) + self.height - 3
						w.height = 1
						w.caption = v.caption
						w.onClick = v.onClick
					end

					self.message.buttons = nil
				end

				if self.widgets ~= nil then
					for i, v in ipairs(self.widgets) do
						v:refresh()
					end
				end
			end
		end,

		mouseClick = function(self, button, x, y)
			if self.widgets ~= nil then
				for i, widget in ipairs(self.widgets) do
					if (x >= widget.left) and (x < widget.left + widget.width) and 
					   (y > widget.top) and (y <= widget.top + widget.height) then
						self.focusedWidget = widget
						widget.focused = true

						if button == 1 then
							if widget.onClick ~= nil then
								widget:onClick()
							end
						else
							if widget.onPopup ~= nil then
								widget:onPopup()
							end
						end

						if widget.onMouseClick ~= nil then
							widget:onMouseClick(button, x, y)
						end

						if widget.mouseClick ~= nil then
							widget:mouseClick(button, x, y)
						end
					end
				end
			end
		end,


		keyPress = function(self, key, char)
			--error(key .. " " .. char)
			--if self.focusedWidget ~= nil then
			--	if self.focusedWidget.keyPress ~= nil then
			--		self.focusedWidget:keyPress(key, char)
			--	end
			--end
			--error(key .. "k")
			self.widgets.edit:keyPress(key, char)
		end,


		getCanvas = function(self)
			return self.canvas
		end
	}


	return messageBox
end]])
table.insert(names, "/system/form")
table.insert(values, [[
function Create(name)
	local form = {
		name = name,
		parent = nil,
		widgets = {},
		focusedWidget = nil,
		style = "double",
		controlBox = true,
		lastZOrder = 0,
		bgcolor = colors.lightGray,
		os = nil,
		left = 0, --For compatibility with widgets.Panel
		top = 0,
		drawTitle = true,


		refresh = function(self)
			if self.parent ~= nil then
				if self.drawTitle then
					self.parent.canvas:fillrect(1, 1, self.parent.canvas.size.x, 1, colors.blue)
					self.parent.canvas:fillrect(1, 2, self.parent.canvas.size.x, self.parent.canvas.size.y - 1, self.bgcolor)
					self.parent.canvas:setCursorPos(2, 1)

					self.parent.canvas.bgcolor = colors.blue
					self.parent.canvas.forecolor = colors.white
					self.parent.canvas:write(self.name)
				else
					self.parent.canvas:fillrect(1, 1, self.parent.canvas.size.x, self.parent.canvas.size.y - 1, self.bgcolor)
				end

				self.os = self.parent.os

				if self.controlBox then
					self.parent.canvas:setCursorPos(self.parent.canvas.size.x - 1, 1)
					self.parent.canvas.bgcolor = colors.red
					self.parent.canvas.forecolor = colors.white
					self.parent.canvas:write(" X")

					self.parent.canvas:setCursorPos(self.parent.canvas.size.x - 3, 1)
					self.parent.canvas.bgcolor = colors.blue
					self.parent.canvas.forecolor = colors.white
					self.parent.canvas:write("- ")
				end

				if self.onRefresh ~= nil then
					self:onRefresh()
				end


				t = {}

				for k, v in pairs(self.widgets) do
					table.insert(t, v)
				end


				local sort = function(arg1, arg2)
					return arg1.zOrder < arg2.zOrder
				end

				table.sort(t, sort)


				--for k, v in pairs(self.widgets) do
				for k, v in ipairs(t) do
					if self.focusedWidget == v then
						v.focused = true
					else
						v.focused = false

						if v.onRefresh ~= nil then
							v:onRefresh()
						end

						if v.visible == true then
							v:refresh()
						end
					end
				end

				if self.focusedWidget ~= nil then
					if self.focusedWidget.onRefresh ~= nil then
						self.focusedWidget:onRefresh()
					end

					self.focusedWidget:refresh()
				end
			end
		end,


		show = function(self)
			if self.parent ~= nil then
				self.parent.activeForm = self
				self.parent.info.title = self.name
			end
		end,


		mouseClick = function(self, button, x, y)
			--\[\[self.parent.canvas.cursorPos.x = 1
			self.parent.canvas.cursorPos.y = 2

			self.parent.canvas:write(x)
			self.parent.canvas:write(" ")
			self.parent.canvas:write(y)\]\]
			self.focusedWidget = nil

			if self.controlBox then
				if (x == self.parent.canvas.size.x) and (y == 1) then
					if self.onTerminate ~= nil then
						if self:onTerminate() then
							self.parent:terminate()
						end
					else
						self.parent:terminate()
					end
				end

				if (x == self.parent.canvas.size.x - 3) and (y == 1) then
					self.parent.os.setActiveProcess(-1)
				end
			end


			if --\[\[self.focusedWidget ~= nil\]\] false then
				local widget = self.focusedWidget
				if (x >= widget.left) and (x <= widget.left + widget.width) and 
					(y > widget.top) and (y <= widget.top + widget.height) then
					if button == 1 then
						if widget.onClick ~= nil then
							widget:onClick()
						end
					else
						if widget.onPopup ~= nil then
							widget:onPopup()
						end
					end

					if widget.onMouseClick ~= nil then
						widget:onMouseClick(button, x, y)
					end

					if widget.mouseClick ~= nil then
						widget:mouseClick(button, x, y)
					end
				end
			end

			for name, widget in pairs(self.widgets) do
				if (x >= widget.left) and (x < widget.left + widget.width) and 
					(y > widget.top) and (y <= widget.top + widget.height) then
					self.focusedWidget = widget


					if widget.onMouseClick ~= nil then
						widget:onMouseClick(button, x, y)
					end

					if widget.mouseClick ~= nil then
						widget:mouseClick(button, x, y)
					end


					if button == 1 then
						if widget.onClick ~= nil then
							widget:onClick()
						end
					else
						if widget.onPopup ~= nil then
							widget:onPopup()
						end
					end
				end
			end
		end,


		mouseDrag = function(self, button, x, y)
			self.focusedWidget = nil

			for name, widget in pairs(self.widgets) do
				if (x >= widget.left) and (x < widget.left + widget.width) and 
					(y > widget.top) and (y <= widget.top + widget.height) then
					self.focusedWidget = widget


					if widget.onMouseDrag ~= nil then
						widget:onMouseDrag(button, x, y)
					end

					if widget.mouseDrag ~= nil then
						widget:mouseDrag(button, x, y)
					end
				end
			end
		end,


		keyPress = function(self, key, char)
			if self.focusedWidget ~= nil then
				if self.focusedWidget.keyPress ~= nil then
					self.focusedWidget:keyPress(key, char)
				end
			end

			if self.onKeyPress ~= nil then
				self:onKeyPress(key, char)
			end
		end,


		getCanvas = function(self)
			return self.parent.canvas
		end,
	}

	return form
end]])
table.insert(names, "/system/iniFiles")
table.insert(values, [[
function split(pString, pPattern)
   local Table = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pPattern
   local last_end = 1
   local s, e, cap = pString:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
		table.insert(Table,cap)
      end
      last_end = e+1
      s, e, cap = pString:find(fpat, last_end)
   end
   if last_end <= #pString then
      cap = pString:sub(last_end)
      table.insert(Table, cap)
   end
   return Table
end

function string.starts(String,Start)
   return string.sub(String,1,string.len(Start))==Start
end

function string.ends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end






function read(fileName)
	local result = {}

	if string.starts(fileName, "home:/") then
		fileName = string.gsub(fileName, "home:/", "", 1)
	end

	if fs.exists(fileName) then
		local file = fs.open(fileName, "r")
		local data = file.readAll()
		file.close()

		data = string.gsub(data, "\r", "")
		local lines = split(data, "\n")
		local cat = "*"

		for i, v in ipairs(lines) do
			if (string.len(v) > 0) and (not string.starts(v, ";")) then
				if string.starts(v, "[") and string.ends(v, "]") then
					local catName = string.gsub(v, "%[", "")
					catName = string.gsub(catName, "%]", "")
					cat = catName
				else
					if string.find(v, "=") then
						local values = split(v, "=")

						if string.ends(values[1], " ") then
							repeat
								values[1] = string.sub(values[1], 1, string.len(values[1]) - 1)
							until not (string.ends(values[1], " "))
						end

						if string.starts(values[2], " ") then
							repeat
								values[2] = string.sub(values[2], 2, string.len(values[2]))
							until not (string.starts(values[2], " "))
						end

						if result[cat] == nil then result[cat] = {} end
						if result[cat][values[1\]\] == nil then result[cat][values[1\]\] = {} end
						result[cat][values[1\]\] = values[2]
					end
				end
			end
		end

		return result
	end
end


function write(fileName, iniData)
	local data = ""

	for k, v in pairs(iniData) do
		data = data .. "[" .. k .. "]\r\n"

		for k2, v2 in pairs(v) do
			data = data .. k2 .. " = " .. v2 .. "\r\n"
		end
	end

	local file = fs.open(fileName, "w")
	file.write(data)
	file.close()
end]])
table.insert(names, "/system/pathutils")
table.insert(values, [[
function split(self, sep)
    local sep, fields = sep or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    self:gsub(pattern, function(c) fields[#fields+1] = c end)
    return fields
end

function string.starts(String,Start)
   return string.sub(String,1,string.len(Start))==Start
end

function string.ends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end



function expand(line)
	local expanded = split(line, " ")
	local args = {}
	local i = 1

	repeat
		if string.starts(expanded[i], "\"") and (not string.ends(expanded[i], "\"")) then
			local str = ""

			repeat
				str = str .. expanded[i] .. " "
				i = i + 1
			until string.ends(expanded[i-1], "\"")

			str = string.gsub(str, "\"", "")
			str = string.sub(str, 1, string.len(str) - 1)
			table.insert(args, str)
		else
			expanded[i] = string.gsub(expanded[i], "\"", "")
			table.insert(args, expanded[i])
		end

		i = i + 1
	until i > #expanded

	return args
end


function extractFilePath(fileName)
	if string.starts(fileName, "home:/") then
		fileName = string.gsub(fileName, "home:/", "")
	end

	fileName = string.gsub(fileName, "//", "/")


	local data = split(fileName, "/")
	local result = ""

	if #data > 1 then
		for i = 1, #data - 1 do
			result = result .. data[i] .. "/"
		end
	else
		result = ""
	end

	--error(result)
	return "home:/" .. result
end


function extractFileName(fileName)
	if (fileName ~= nil) and (type(fileName) == "string") then
		local data = split(fileName, "/")
		return data[#data]
	else
		return ""
	end
end


function extractRealFileName(fileName)
	if (fileName ~= nil) and (type(fileName) == "string") then
		local data = extractFileName(split(fileName, "%."))
		return data[1]
	else
		return ""
	end
end


function buildUp(args)
	local result = ""

	for i, v in ipairs(args) do
		result = result .. v .. " "
	end

	return result
end]])
table.insert(names, "/system/user")
table.insert(values, [[local lastCursorBlink = false
local oldSetCursorBlink = term.setCursorBlink

function split(self, sep)
    local sep, fields = sep or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    self:gsub(pattern, function(c) fields[#fields+1] = c end)
    return fields
end

function stringstarts(String,Start)
   return string.sub(String,1,string.len(Start))==Start
end

function stringends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end

function round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end



term.setCursorBlink = function(bool)
	lastCursorBlink = bool
	oldSetCursorBlink(bool)
end



function CreateCanvas(sizeX, sizeY)
	local videoData = { }

	for y = 1, sizeY do
		videoData[y] = { }
		for x = 1, sizeX do
			videoData[y][x] = { bgcolor = colors.white, forecolor = colors.black, char = " " }
		end
	end


	local canvas = {
		size = { x = sizeX, y = sizeY },
		cursorPos = { x = 1, y = 1 },
		data = videoData,
		bgcolor = colors.white,
		forecolor = colors.black,
		autoScroll = false,
		showCursor = true,
		cursorBlink = false,
		effect = nil,


		render = function(self, left, top, changeBlinking)
			local cx, cy = term.getCursorPos()
			local oldBlink = lastCursorBlink

			--if changeBlinking == true then term.setCursorBlink(self.cursorBlink) end

			for y = 1, self.size.y do
				if self.data[y] ~= nil then
					for x = 1, self.size.x do
						if self.data[y][x] ~= nil then
							term.setCursorPos(x + left, y + top)

							if type(self.data[y][x].bgcolor) == "number" then
								if self.effect ~= nil then
									term.setBackgroundColor(self.effect:getbgcolor(x, y, self.data[y][x].bgcolor, self.data[y][x].forecolor, self.data[y][x].char))
								else
									if self.data[y][x].bgcolor > 0 then
										term.setBackgroundColor(self.data[y][x].bgcolor)
									end
								end
							end

							if self.effect ~= nil then
								term.setTextColor(self.effect:getforecolor(x, y, self.data[y][x].bgcolor, self.data[y][x].forecolor, self.data[y][x].char))
								term.write(self.effect:getchar(x, y, self.data[y][x].bgcolor, self.data[y][x].forecolor, self.data[y][x].char))
							else
								term.setTextColor(self.data[y][x].forecolor)

								if self.data[y][x].bgcolor ~= 0 then
									term.write(self.data[y][x].char)
								else
									local x, y = term.getCursorPos()
									term.setCursorPos(x + 1, y)
								end
							end
						end
					end
				end
			end

			--if changeBlinking == true then term.setCursorBlink(oldBlink) end
			--term.setCursorPos(cx, cy)
		end,


		clear = function(self)
			for y = 1, self.size.y do
				for x = 1, self.size.x do
					self.data[y][x] = { bgcolor = self.bgcolor, forecolor = self.forecolor, char = " " }
				end
			end
		end,


		dublicate = function(self)
			local function copyTable(t)
				local n = {}
				for k, v in pairs(t) do
					if not type(v) == "table" then
						n[k] = v
					else
						n[k] = copyTable(v)
					end
				end
				return n
			end

			return copyTable(self)
		end,


		scale = function(self, sizeX, sizeY)
			if (sizeX == self.size.x) and (sizeY == self.size.y) then
				return self
			end

			local ratioX = self.size.x / sizeX
			local ratioY = self.size.y / sizeY
			local new = CreateCanvas(sizeX, sizeY)
			local copiedX = 0
			local copiedY = 0
			local cx = 1
			local cy = 1

			for y = 1, sizeY do
				copiedY = copiedY + ratioY
				cy = cy + math.floor(copiedY)
				copiedY = copiedY - math.floor(copiedY)
				copiedX = 0
				cx = 1
				for x = 1, sizeX do
					copiedX = copiedX + ratioX
					cx = cx + math.floor(copiedX)
					copiedX = copiedX - math.floor(copiedX)
					new.data[y][x] = (self.data[cy] or {})[cx] or
						{ bgcolor = colors.white, forecolor = colors.black, char = " " }
				end
			end

			return new
		end,


		--scaleToFit = function(self, sizeX, sizeY)
		--	if 
		--end,


		write = function(self, str)
			for c in string.gmatch(str, ".") do
				if (self.cursorPos.y >= 1) and (self.cursorPos.y <= self.size.y) and
					(self.cursorPos.x >= 1) and (self.cursorPos.x <= self.size.x) then

					self.data[self.cursorPos.y][self.cursorPos.x].char = c
					self.data[self.cursorPos.y][self.cursorPos.x].bgcolor = self.bgcolor
					self.data[self.cursorPos.y][self.cursorPos.x].forecolor = self.forecolor
					self.cursorPos.x = self.cursorPos.x + 1

					if self.cursorPos.x > self.size.x then
						self.cursorPos.x = 1
						self.cursorPos.y = self.cursorPos.y + 1

						if (self.autoScroll) and (self.cursorPos.y >= self.size.y) then
							self.size.y = self.size.y + 1

							self.data[self.size.y] = {}
							for x = 1, self.size.x do
								self.data[self.size.y][x] = { bgcolor = self.bgcolor, forecolor = self.forecolor, char = " " }
							end
						end
					end
				end
			end
		end,


		fillrect = function(self, left, top, width, height, bgcolor)
			for y = top, top + height do
				for x = left, left + width do
					if (y >= 1) and (y <= self.size.y) and
						(x >= 1) and (x <= self.size.x) then
						self.data[y][x].bgcolor = bgcolor
						self.data[y][x].char = " "
					end
				end
			end
		end,


		print = function(self, str)
			local function newLine()
				self.cursorPos.x = 1
				self.cursorPos.y = self.cursorPos.y + 1

				if (self.autoScroll) and (self.cursorPos.y > self.size.y) then
					self.size.y = self.size.y + 1
					--print(self.size.y)
					self.data[self.size.y] = {}
					for x = 1, self.size.x do
						self.data[self.size.y][x] = { bgcolor = self.bgcolor, forecolor = self.forecolor, char = " " }
					end
				end
			end


			local function printBlock(block)
				local words = split(block, " ")

				for i, v in ipairs(words) do
					if i < #words then
						if self.cursorPos.x + string.len(v) + 1 > self.size.x then
							newLine()
						end
						self.write(self, v .. " ")
					else
						if self.cursorPos.x + string.len(v) > self.size.x then
							newLine()
						end
						self.write(self, v)
					end
				end
			end

			str = str .. "\n"
			blocks = split(str, "\n")

			for i, v in ipairs(blocks) do
				printBlock(v)
				newLine()
			end
		end,


		draw = function(self, left, top, graphic, arg1, transparent, transColor)
			if transparent then
				transColor = transColor or colors.white
			else
				transColor = nil
			end

			for y = 1, graphic.size.y do
				for x = 1, graphic.size.x do
					if (y + top >= 1) and (y + top <= self.size.y) and
					   (x + left >= 1) and (x + left <= self.size.x) and
					   (y >= 1) and (y <= graphic.size.y) and
					   (x >= 1) and (x <= graphic.size.x) then
						if (transparent and graphic.data[y][x].bgcolor ~= transColor) or not transparent then
							if graphic.effect ~= nil then
								self.data[y + top][x + left].char = 
									graphic.effect:getchar(x, y, graphic.data[y][x].bgcolor, graphic.data[y][x].forecolor, graphic.data[y][x].char)
								self.data[y + top][x + left].bgcolor = 
									graphic.effect:getbgcolor(x, y, graphic.data[y][x].bgcolor, graphic.data[y][x].forecolor, graphic.data[y][x].char)
								self.data[y + top][x + left].forecolor = 
									graphic.effect:getforecolor(x, y, graphic.data[y][x].bgcolor, graphic.data[y][x].forecolor, graphic.data[y][x].char)
							else
								--if graphic.data[y][x].char ~= "\r" then self.data[y + top][x + left].char = graphic.data[y][x].char else
								--	self.data[y + top][x + left].char = "^" end

								self.data[y + top][x + left].char = graphic.data[y][x].char
								self.data[y + top][x + left].bgcolor = graphic.data[y][x].bgcolor
								self.data[y + top][x + left].forecolor = graphic.data[y][x].forecolor
							end
						end
					end
				end
			end

			term.setCursorPos(graphic.cursorPos.x, graphic.cursorPos.y)
			term.setCursorBlink(graphic.cursorBlink)
		end,


		point = function(self, x, y, char)
			if self.data[y] ~= nil then
				if self.data[y][x] ~= nil then
					self.data[y][x].bgcolor = self.bgcolor
					self.data[y][x].forecolor = self.forecolor
					self.data[y][x].char = char
				end
			end
		end,


		scroll = function(self, n)
			self:draw(0, -n, self)
			self:fillrect(1, self.size.y - n, self.size.x, n, self.bgcolor)
		end,


		setCursorPos = function(self, x, y)
			self.cursorPos.x = x
			self.cursorPos.y = y
		end,

		getCursorPos = function(self)
			return self.cursorPos.x, self.cursorPos.y
		end,

		getSize = function(self)
			return self.size.x, self.size.y
		end,
	}

	return canvas
end


function getTextColor(color)
	local COLORS = {}

	COLORS[0] = "t" -- transparent
	COLORS[1] = "0"
	COLORS[2] = "1"
	COLORS[4] = "2"
	COLORS[8] = "3"
	COLORS[16] = "4"
	COLORS[32] = "5"
	COLORS[64] = "6"
	COLORS[128] = "7"
	COLORS[256] = "8"
	COLORS[512] = "9"
	COLORS[1024] = "a"
	COLORS[2048] = "b"
	COLORS[4096] = "c"
	COLORS[8192] = "d"
	COLORS[16384] = "e"
	COLORS[32768] = "f"

	return COLORS[color]
end


function getColorFromStr(str)
	local COLORS = {}

	COLORS["t"] = 0 -- transparent
	COLORS["0"] = 1
	COLORS["1"] = 2
	COLORS["2"] = 4
	COLORS["3"] = 8
	COLORS["4"] = 16
	COLORS["5"] = 32
	COLORS["6"] = 64
	COLORS["7"] = 128
	COLORS["8"] = 256
	COLORS["9"] = 512
	COLORS["a"] = 1024
	COLORS["b"] = 2048
	COLORS["c"] = 4096
	COLORS["d"] = 8192
	COLORS["e"] = 16384
	COLORS["f"] = 32768

	return COLORS[str]
end


function pixelToString(pixel)
	local bgcolor = getTextColor(pixel.bgcolor)
	local forecolor = getTextColor(pixel.forecolor)
	local char = string.sub(pixel.char, 1, 2) or " "

	return bgcolor .. forecolor .. char
end





function saveCanvas(canvas, fileName)
	fileName = string.gsub(fileName, "home:/", "")

	if canvas ~= nil then
		local data = "pic|" .. canvas.size.y .. "|" .. canvas.size.x .. "|"

		for y = 1, canvas.size.y do
			for x = 1, canvas.size.x do
				data = data .. pixelToString(canvas.data[y][x])
			end
		end

		local file = fs.open(fileName, "w")

		if file ~= nil then
			file.write(data)
			file.close()
		end
	end
end


function loadCanvas(fileName)
	fileName = string.gsub(fileName, "home:/", "")
	local canvas = nil

	if (fs.exists(fileName)) and (fs.isDir(fileName) == false) then
		local file = fs.open(fileName, "r")

		if file ~= nil then
			local data = file.readAll()
			file.close()

			local sections = split(data, "|")

			if sections[1] == "pic" then
				local sizeY = tonumber(sections[2])
				local sizeX = tonumber(sections[3])
				local datasec = sections[4]

				canvas = CreateCanvas(sizeX, sizeY)

				for y = 1, sizeY do
					for x = 1, sizeX do
						local index = (((y - 1) * sizeX + (x - 1)) * 3) + 1
						local bgcolor = getColorFromStr(string.sub(datasec, index, index))
						local forecolor = getColorFromStr(string.sub(datasec, index + 1, index + 1))
						local char = string.sub(datasec, index + 2, index + 2)

						--error(index .. ":" .. string.sub(datasec, index, index) .. "!")

						canvas.data[y][x].bgcolor = bgcolor
						canvas.data[y][x].forecolor = forecolor
						canvas.data[y][x].char = char
					end
				end

				return canvas
			end
		end
	end
end






function contrast_color(color)
	if color == colors.black then return colors.white end
	if color == colors.orange then return colors.black end
	if color == colors.magenta then return colors.black end
	if color == colors.lightBlue then return colors.black end
	if color == colors.yellow then return colors.black end
	if color == colors.lime then return colors.white end
	if color == colors.pink then return colors.white end
	if color == colors.gray then return colors.white end
	if color == colors.lightGray then return colors.black end
	if color == colors.cyan then return colors.white end
	if color == colors.purple then return colors.white end
	if color == colors.blue then return colors.white end
	if color == colors.brown then return colors.white end
	if color == colors.green then return colors.white end
	if color == colors.red then return colors.white end
	if color == colors.white then return colors.black end
	return colors.white
end



function CreateEffect_Shadow()
	local effect = {
		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			if bgcolor == colors.black then return colors.gray end
			if bgcolor == colors.orange then return colors.lightGray end
			if bgcolor == colors.magenta then return colors.lightGray end
			if bgcolor == colors.lightBlue then return colors.lightGray end
			if bgcolor == colors.yellow then return colors.lightGray end
			if bgcolor == colors.lime then return colors.lightGray end
			if bgcolor == colors.pink then return colors.lightGray end
			if bgcolor == colors.gray then return colors.gray end
			if bgcolor == colors.lightGray then return colors.gray end
			if bgcolor == colors.cyan then return colors.gray end
			if bgcolor == colors.purple then return colors.gray end
			if bgcolor == colors.blue then return colors.gray end
			if bgcolor == colors.brown then return colors.gray end
			if bgcolor == colors.green then return colors.gray end
			if bgcolor == colors.red then return colors.lightGray end
			if bgcolor == colors.white then return colors.lightGray end
			return colors.gray
		end,

		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			if forecolor == colors.black then return colors.gray end
			if forecolor == colors.orange then return colors.lightGray end
			if forecolor == colors.magenta then return colors.lightGray end
			if forecolor == colors.lightBlue then return colors.lightGray end
			if forecolor == colors.yellow then return colors.lightGray end
			if forecolor == colors.lime then return colors.lightGray end
			if forecolor == colors.pink then return colors.lightGray end
			if forecolor == colors.gray then return colors.gray end
			if forecolor == colors.lightGray then return colors.gray end
			if forecolor == colors.cyan then return colors.gray end
			if forecolor == colors.purple then return colors.gray end
			if forecolor == colors.blue then return colors.gray end
			if forecolor == colors.brown then return colors.gray end
			if forecolor == colors.green then return colors.gray end
			if forecolor == colors.red then return colors.lightGray end
			if forecolor == colors.white then return colors.lightGray end
			return colors.gray
		end,

		getchar = function(self, x, y, bgcolor, forecolor, char)
			return char
		end,
	}


	return effect
end



function CreateEffect_Acid()
	local function RANDOMCOLOR(COLOR_BASE)
		local COLORS = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768 }
		math.randomseed(COLOR_BASE * os.time())

		if COLORS[math.random(1, 16)] ~= nil then
			return COLORS[math.random(1, 16)]
		else
			return colors.white
		end
	end


	local effect = {
		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			return RANDOMCOLOR(bgcolor / 2)
		end,

		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			return RANDOMCOLOR(forecolor / 2)
		end,

		getchar = function(self, x, y, bgcolor, forecolor, char)
			return char
		end,
	}

	return effect
end


function CreateEffect_ListViewSelect()
	local effect = {
		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			if bgcolor == colors.black then return colors.blue end
			if bgcolor == colors.orange then return colors.blue end
			if bgcolor == colors.magenta then return colors.lightBlue end
			if bgcolor == colors.lightBlue then return colors.blue end
			if bgcolor == colors.yellow then return colors.lightBlue end
			if bgcolor == colors.lime then return colors.lightBlue end
			if bgcolor == colors.pink then return colors.lightBlue end
			if bgcolor == colors.blue then return colors.blue end
			if bgcolor == colors.lightGray then return colors.lightBlue end
			if bgcolor == colors.cyan then return colors.blue end
			if bgcolor == colors.purple then return colors.blue end
			if bgcolor == colors.blue then return colors.blue end
			if bgcolor == colors.brown then return colors.blue end
			if bgcolor == colors.green then return colors.blue end
			if bgcolor == colors.red then return colors.lightBlue end
			if bgcolor == colors.white then return colors.lightBlue end
			return colors.blue
		end,

		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			if self:getbgcolor(x, y, bgcolor, forecolor, char) == colors.blue then return colors.lightBlue else return colors.blue end
		end,

		getchar = function(self, x, y, bgcolor, forecolor, char)
			return char
		end,
	}


	return effect
end]])
table.insert(names, "/system/widgets/button")
table.insert(values, [[

function Create(_parent, name)
	local button = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 1,
		width = 10,
		caption = name,
		focused = false,
		visible = true,
		bgcolor = colors.gray,
		forecolor = colors.white,
		forecolor2 = colors.red,
		align = "center",
		lastBgColor = colors.gray,


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local textY = 0
			local str = string.sub(self.caption, 2, string.len(self.caption))
			local first = string.sub(self.caption, 1, 1)

			if self.parent.style ~= "none" then
				y = y + 1
			end

			textY = y + math.floor(self.height / 2)

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, self.bgcolor)
			

			if string.len(str) + 2 > self.width then
				str = string.sub(str, 1, self.width - 3) .. ".."
			end



			x = self.left + math.floor(self.width / 2) - math.ceil((string.len(str) +1) / 2)
			--x = self.left + math.floor(self.width / 2) - math.floor(string.len(str) / 2)


			--x = self.left

			--if string.len(str) > self.width then
			--	str = string.sub(str, 1, self.width - 2) .. ".."
			--end

			--\[\[if self.align == "right" then
				x = self.left + self.width - string.len(str) + 1
			end

			if self.align == "center" then
				x = self.left + math.floor(self.width / 2) - math.floor((string.len(str) + 1) / 2)
			end\]\]



			if string.len(str) > self.width then str = string.sub(str, 0, self.width - 1) end
			if x < self.left then x = self.left end

			canvas:setCursorPos(x, textY)
			canvas.bgcolor = self.bgcolor
			canvas.forecolor = self.forecolor2
			canvas:write(first)
			canvas.forecolor = self.forecolor
			canvas:write(str)
		end,


		mouseClick = function(self, button, x, y)
			--self.lastBgColor = self.bgcolor
			--self.bgcolor = colors.blue
			--self:refresh()
			--self.bgcolor = lastBgColor
		end,
	}

	_parent.widgets[name] = button
	_parent.lastZOrder = _parent.lastZOrder + 1
	button.zOrder = _parent.lastZOrder
	return button
end]])
table.insert(names, "/system/widgets/checkbox")
table.insert(values, [[

function Create(_parent, name)
	local checkbox = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 1,
		width = 10,
		bgcolor = colors.lightGray,
		forecolor = colors.black,
		caption = name,
		focused = false,
		visible = true,
		checked = false,
		grayed = false,


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left + 4
			local y = self.top
			local str = self.caption

			if self.parent.style ~= "none" then
				y = y + 1
			end

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, self.bgcolor)
			
			if string.len(str) > self.width - 4 then
				str = string.sub(str, 1, self.width - 2 - 4) .. ".."
			end

			canvas:setCursorPos(x, y)
			canvas.bgcolor = self.bgcolor
			canvas.forecolor = self.forecolor
			canvas:write(str)

			canvas:setCursorPos(x - 4, y)
			canvas:write("[ ]")
			canvas:setCursorPos(x - 3, y)

			if self.grayed then
				canvas.bgcolor = colors.gray
			else
				canvas.bgcolor = colors.white
			end

			canvas.forecolor = colors.black
			if self.checked then
				canvas:write("X")
			else
				canvas:write(" ")
			end
		end,


		mouseClick = function(self, button, x, y)
			if not self.grayed then
				self.checked = not self.checked
				if self.onChange ~= nil then
					self:onChange()
				end
				self:refresh()
			end
		end,
	}

	_parent.widgets[name] = checkbox
	_parent.lastZOrder = _parent.lastZOrder + 1
	checkbox.zOrder = _parent.lastZOrder
	return checkbox
end]])
table.insert(names, "/system/widgets/edit")
table.insert(values, [[

function Create(_parent, name)
	local edit = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 1,
		width = 10,
		bgcolor = colors.white,
		forecolor = colors.black,
		text = name,
		focused = false,
		visible = true,
		align = "left",
		cursor = 0,
		editable = true,


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local str = self.text
			local inputText = ""

			if self.parent.style ~= "none" then
				y = y + 1
			end

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, self.bgcolor)
			
			if string.len(str) > self.width - 1 then
				str = string.sub(str, 1, self.width - 4) .. ".."
			end

			if self.align == "right" then
				x = self.left + self.width - string.len(str)
			end

			if self.align == "center" then
				x = self.left + math.floor(self.width / 2) - math.floor(string.len(str) / 2)
			end

			if self.focused == false then
				canvas:setCursorPos(x, y)
				canvas.bgcolor = self.bgcolor
				canvas.forecolor = colors.lightGray
				canvas:write("> ")
				canvas.forecolor = self.forecolor
				canvas:write(str)
				canvas.cursorBlink = false

				if self.parent.parent.os ~= nil then
					self.parent.parent.os.hideCaret()
				end
			else
				canvas.bgcolor = self.bgcolor
				canvas.forecolor = self.forecolor
				canvas:setCursorPos(self.left, y)
				canvas.cursorBlink = true

				if string.len(self.text) > self.width - 2 then
					inputText = string.sub(self.text, string.len(self.text) - self.width + 2, string.len(self.text))
				else
					inputText = self.text
				end

				canvas:write(inputText)

				if self.parent.parent.os ~= nil then
					self.parent.parent.os.showCaret()
					self.parent.parent.os.setCaretPos(canvas.cursorPos.x + self.parent.left, canvas.cursorPos.y + self.parent.top)
					self.parent.parent.os.setCaretColor(self.forecolor)
				end
			end
		end,


		--mouseClick = function(self, button, x, y)

		--end,


		keyPress = function(self, key, char)
			if self.editable then
				if key == 14 then
					if string.len(self.text) > 0 then
						self.text = string.sub(self.text, 1, string.len(self.text) - 1)
					end
				else
					self.text = self.text .. char
				end
			end
		end,
	}

	_parent.widgets[name] = edit
	_parent.lastZOrder = _parent.lastZOrder + 1
	edit.zOrder = _parent.lastZOrder
	return edit
end]])
table.insert(names, "/system/widgets/fileListView")
table.insert(values, [[
function startswith(sbig, slittle)
  if type(slittle) == "table" then
    for k,v in ipairs(slittle) do
      if string.sub(sbig, 1, string.len(v)) == v then 
        return true
      end
    end
    return false
  end
  return string.sub(sbig, 1, string.len(slittle)) == slittle
end



function Create(_parent, name)
	local fileListView = listView.Create(_parent, name)
	fileListView.path = "home:/"
	fileListView.firstRefresh = false
	fileListView.history = {}
	fileListView.use_history = false
	fileListView.icon_buffer = {}
	fileListView.hide_lnk_ext = true
	fileListView.dirOnly = false


	fileListView.getIcon = function(self, item)
		local ext = ""
		local result = nil
		local os2 = self.parent.parent.os

		if item ~= nil then
			s = item.name

			if (string.len(s) > 0) and (string.find(s, "%.") and s[0] ~= "." ) then
				local fn = user.split(s, ".")
				ext = fn[#fn]
			else
				if item.dir then
					ext = "folder"
				else
					ext = "unknown"
				end
			end

			if user.stringstarts(name, ".") and item.dir then
				ext = "folder"
			end
		end


		if self.icon_buffer[ext] == nil then
			local fileName = os2.getSystemPath() .. "/system2/" .. ext .. ".pic"

			if not fs.exists(fileName) then
				fileName = os2.getSystemPath() .. "/system2/unknown.pic"
			end

			local icon = user.loadCanvas("home:/" .. fileName)
			self.icon_buffer[ext] = icon
			result = icon
		else
			result = self.icon_buffer[ext]
		end

		if ext == "lnk" then
			pcall(function()
				local lnkdata = iniFiles.read(self.path .. "/" .. item.name)

				if lnkdata ~= nil then
					if lnkdata.shortcut ~= nil then
						local icon = lnkdata.shortcut.icon

						if icon ~= nil then
							result = user.loadCanvas(icon):scale(4, 3)
							result.data[3][1].bgcolor = colors.white
							result.data[3][1].forecolor = colors.black
							result.data[3][1].char = "L"
						end
					end
				end
			end)
		end


		if result == nil then
			result = user.CreateCanvas(4, 3)
		end

		return result
	end


	fileListView.refreshList = function(self)
		local path = string.gsub(self.path, "home:/", "", 1) .. "/"

		self.list = {}
		self.selectedList = {}
		self.offset = 0
		self.widgets.scrollBar.value = 0

		local b_files = fs.list(path)
		local t_files = {}
		local files = {}

		for i, v in ipairs(b_files) do
			if fs.isDir(path .. "/" .. v) then table.insert(files, v) else table.insert(t_files, v) end
		end

		if not self.dirOnly then
			for i, v in ipairs(t_files) do
				table.insert(files, v)
			end
		end



		for i, v in ipairs(files) do
			table.insert(self.list, { icon = {}, name = v, dir = fs.isDir(path .. "/" .. v) })
		end
	end


	fileListView.navigate = function(self, path, addToHistory, _os)
		if not startswith(path, "home:/") then
			path = self.path .. "/" .. path
		end


		local str = string.gsub(path, "home:/", "", 1) .. "/"

		if fs.isDir(str) then
			if not (addToHistory == false) then
				table.insert(self.history, self.path)
			end

			self.path = path
			if self.onNavigate ~= nil then self:onNavigate(path) end
			self.selectedList = {}
			self:refreshList()
		else
			if _os ~= nil then
				_os.shell.run(path)
			end
		end
	end


	fileListView.goBack = function(self)
		if self.use_history then
			local addr = table.remove(self.history)
			if addr ~= nil then
				self:navigate(addr, false, nil)
			end
		else
			local addr = user.split(self.path, "/")

			if #addr > 1 then
				local path = ""

				for i = 1, #addr - 1 do
					path = path .. addr[i] .. "/"
				end

				self:navigate(path, false, nil)
			end
		end
	end


	fileListView.contextMenuConstructor = function(sender, item)
		local menu = popupMenu.Create()
		table.insert(menu.items, popupMenu.CreateItem("New", function(sender)  end))

		return menu
	end


	--fileListView.onRefresh = function(self)
	--	if self.firstRefresh then
	--		self:refreshList()
	--		self.firstRefresh = false
	--	end
	--end


	return fileListView
end]])
table.insert(names, "/system/widgets/glSurface")
table.insert(values, [[function Create(_parent, name)
	local glSurface = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 16,
		width = 24,
		focused = false,
		visible = true,
		glRender = nil,
		--glRender = function(self, gl)


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			canvas:fillrect(self.left, self.top, self.width, self.height, 0)

			if self.glRender ~= nil then
				--\[\[gl = {
					write = function(str)
						for i = 1, string.len(str) do
							local x, y = term.getCursorPos()
							if x + self.left + 1 < self.left + 
						end
				}\]\]
				gl = {
					write = term.write,
					clear = term.clear,
					clearLine = term.clearLine,

					getCursorPos = function()
						local x, y = term.getCursorPos()
						return x - self.left, y - self.top
					end,

					setCursorPos = function(x, y)
						term.setCursorPos(x + self.left, y + self.top)
					end,

					setCursorBlink = function(bool)
					end,

					isColor = term.isColor,

					getSize = function()
						return self.width, self.height
					end,

					scroll = term.scroll,

					redirect = function(target)
					end,

					setTextColor = term.setTextColor,
					setBackgroundColor = term.setBackgroundColor,
				}

				self:glRender(gl)
			end
		end,
	}


	_parent.widgets[name] = glSurface
	_parent.lastZOrder = _parent.lastZOrder + 1
	glSurface.zOrder = _parent.lastZOrder
	return glSurface
end]])
table.insert(names, "/system/widgets/label")
table.insert(values, [[

function Create(_parent, name)
	local label = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 1,
		width = 10,
		bgcolor = colors.lightGray,
		forecolor = colors.black,
		caption = name,
		focused = false,
		visible = true,
		align = "left",


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local str = self.caption

			if self.parent.style ~= "none" then
				y = y + 1
			end

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, self.bgcolor)
			
			if string.len(str) > self.width then
				str = string.sub(str, 1, self.width - 2) .. ".."
			end

			if self.align == "right" then
				x = self.left + self.width - string.len(str)
			end

			if self.align == "center" then
				x = self.left + math.floor(self.width / 2) - math.floor(string.len(str) / 2)
			end

			canvas:setCursorPos(x, y)
			canvas.bgcolor = self.bgcolor
			canvas.forecolor = self.forecolor
			canvas:write(str)
		end
	}

	_parent.widgets[name] = label
	_parent.lastZOrder = _parent.lastZOrder + 1
	label.zOrder = _parent.lastZOrder
	return label
end]])
table.insert(names, "/system/widgets/listBox")
table.insert(values, [[
function Create(_parent, name)
	local listBox = panel.Create(_parent, name)

	listBox.selected = {
		bgcolor = colors.blue,
		forecolor = colors.white,
	}

	listBox.bgcolor = colors.white
	listBox.forecolor = colors.black
	listBox.columns = 1
	listBox.columnWidth = {}

	listBox.checkBoxes = false

	listBox.list = {}
	listBox.selectedList = {}
	listBox.showScroll = true
	listBox.offset = 0
	listBox.index = 1
	listBox.widgets.scrollBar = scrollBar.Create(listBox, "scrollBar")

	listBox.widgets.scrollBar.min = 0
	listBox.widgets.scrollBar.max = 50
	listBox.widgets.scrollBar.value = 0
	listBox.widgets.scrollBar.step = 1

	listBox.widgets.scrollBar.onChange = function(sender)
		sender.parent.offset = sender.value
	end


	listBox.reposition = function(self, height, width)
		self.height = height
		self.width = width

		self.widgets.scrollBar.left = width - 1
		self.widgets.scrollBar.height = height
	end


	listBox.onBeforeRefresh = function(self)
		self:reposition(self.height, self.width)

		local scrollBar = self.widgets.scrollBar
		self.widgets = { scrollBar = scrollBar }

		--\[\[for k, v in pairs(self.widgets) do
			if string.find(k, "item_") then
				self.widgets[k] = nil
			end
		end\]\]

		for i, v in ipairs(self.list) do
			if self.columns == 1 then
				local lbl = {}

				if self.checkBoxes then
					lbl = checkbox.Create(self, "item_" .. tostring(i))
					lbl.checked = v[2] or true
					lbl.grayed = v[3] or false
					lbl.caption = v[1]
					lbl.onChange = function(sender)
						--self.list[sender.tag][2] = sender.checked
						--sender:refresh()
						--error("ss")
						sender.checked = not sender.checked
					end
				else
					lbl = label.Create(self, "item_" .. tostring(i))
					lbl.caption = v
				end

				lbl.left = 1
				lbl.top = i - self.offset
				lbl.width = self.width - 2
				lbl.bgcolor = self.bgcolor
				lbl.forecolor = self.forecolor
				lbl.tag = i

				lbl.onClick = function(sender)
					self.index = sender.tag
					sender.bgcolor = self.selected.bgcolor
					sender.forecolor = self.selected.forecolor
					if self.checkBoxes and not sender.grayed then
						sender.checked = not sender.checked
						self.list[sender.tag][2] = sender.checked
						sender:refresh()
					end
				end

				if i == self.index then
					lbl.bgcolor = self.selected.bgcolor
					lbl.forecolor = self.selected.forecolor
				end
			else
				local left = 1

				for column = 1, self.columns do
					left = left + (self.columnWidth[column - 1] or 0)

					local lbl = label.Create(self, "item_" .. tostring(i) .. "_c_" .. tostring(column))
					lbl.left = left
					lbl.top = i - self.offset

					if column == self.columns then
						lbl.width = self.width - 1 - left
					else
						lbl.width = self.columnWidth[column]
					end

					lbl.bgcolor = self.bgcolor
					lbl.forecolor = self.forecolor
					lbl.caption = v[column]
					lbl.tag = i

					lbl.onClick = function(sender)
						self.index = sender.tag

						for c = 1, sender.parent.columns do
							sender.parent.widgets["item_" .. tostring(i) .. "_c_" .. tostring(c)].bgcolor = self.selected.bgcolor
							sender.parent.widgets["item_" .. tostring(i) .. "_c_" .. tostring(c)].forecolor = self.selected.forecolor
						end
					end

					if i == self.index then
						lbl.bgcolor = self.selected.bgcolor
						lbl.forecolor = self.selected.forecolor
					end
				end
			end
		end
	end


	listBox.getMax = function(self)
		return #self.list - self.height
	end


	listBox.onRefresh = function(self)
		self.widgets.scrollBar.max = self:getMax()
		if self.widgets.scrollBar.max < 0 then self.widgets.scrollBar.max = 0 end
	end


	listBox.clear = function(self)
		self.list = {}
		--self.index = 1
	end


	listBox.add = function(self, item)
		table.insert(self.list, item)
	end


	return listBox
end]])
table.insert(names, "/system/widgets/listView")
table.insert(values, [[
function Create(_parent, name)
	local listView = panel.Create(_parent, name)
	local ITEM_WIDTH = 9
	local ITEM_HEIGHT = 6 --5

	listView.list = {}
	listView.selectedList = {}
	listView.showScroll = true
	listView.offset = 0
	listView.contextMenuConstructor = nil
	listView.widgets.scrollBar = scrollBar.Create(listView, "scrollBar")

	listView.widgets.scrollBar.min = 0
	listView.widgets.scrollBar.max = 50
	listView.widgets.scrollBar.value = 0
	listView.widgets.scrollBar.step = 2

	listView.widgets.scrollBar.onChange = function(sender)
		sender.parent.offset = sender.value
	end


	listView.reposition = function(self, height, width)
		self.height = height
		self.width = width

		self.widgets.scrollBar.left = width - 1
		self.widgets.scrollBar.height = height
	end


	listView.drawItem = function(self, index, selected)
		local item = self.list[index]
		index = index - 1

		if item ~= nil then
			local x = 0
			local y = 0
			local maxX = math.floor((self.width - 2) / ITEM_WIDTH) - 1

			for i = 1, index do
				x = x + 1

				if x > maxX then
					x = 0
					y = y + 1
				end
			end

			x = x * ITEM_WIDTH + 1
			y = y * ITEM_HEIGHT + 1


			y = y - self.offset


			if self.getIcon ~= nil then
				local icon = self:getIcon(self.list[index + 1])

				if selected then
					icon.effect = user.CreateEffect_ListViewSelect()
				else
					icon.effect = nil
				end

				self.canvas:draw(x + 2 - 1, y - 1, icon)
			else
				if selected then
					self.canvas:fillrect(x + 2, y, 3, 2, colors.blue)
				else
					self.canvas:fillrect(x + 2, y, 3, 2, colors.white)
				end
			end



			local text = string.sub(item.name, 1, string.len(item.name))

			if self.hide_lnk_ext == true then
				if user.stringends(text, ".lnk") then
					text = string.sub(text, 1, string.len(text) - 4)
				end
			end

			--if string.len(text) > ITEM_WIDTH - 1 then text = string.sub(text, 1, ITEM_WIDTH - 3) .. ".." end
			if string.len(text) > ITEM_WIDTH - 1 then
				local text1 = string.sub(text, 1, ITEM_WIDTH - 1)
				local text2 = string.gsub(text, text1, "", 1)

				if string.len(text2) > ITEM_WIDTH - 1 then text2 = string.sub(text2, 1, ITEM_WIDTH - 3) .. ".." end

				local text1X = x + math.ceil((ITEM_WIDTH - 2) / 2) - math.ceil(string.len(text1) / 2)
				local text2X = x + math.ceil((ITEM_WIDTH - 2) / 2) - math.ceil(string.len(text2) / 2)

				self.canvas.bgcolor = self.bgcolor
				self.canvas.forecolor = user.contrast_color(self.bgcolor)
				self.canvas:setCursorPos(text1X, y + 3)
				self.canvas:write(text1)
				self.canvas:setCursorPos(text2X, y + 4)
				self.canvas:write(text2)
			else
				local textX = x + math.ceil((ITEM_WIDTH - 2) / 2) - math.ceil(string.len(text) / 2)

				self.canvas.bgcolor = self.bgcolor
				self.canvas.forecolor = user.contrast_color(self.bgcolor)
				self.canvas:setCursorPos(textX, y + 3)
				self.canvas:write(text)
			end
		end
	end



	listView.onBeforeRefresh = function(self)
		self:reposition(self.height, self.width)
	end

	listView.getMax = function(self)
		local list = self.list
		local maxX = math.floor((self.width - 2) / ITEM_WIDTH)
		local max = (math.ceil(#list / maxX) * ITEM_HEIGHT) - self.height
		if max < 0 then max = 0 end

		return max
	end


	listView.onRefresh = function(self)
		self.widgets.scrollBar.max = self:getMax()

		for i, v in ipairs(self.list) do
			if self.canvas ~= nil then
				self:drawItem(i)
			end
		end

		for i, v in ipairs(self.selectedList) do
			if self.canvas ~= nil then
				self:drawItem(v, true)
			end
		end

		if self.onAfterRefresh ~= nil then
			self:onAfterRefresh()
		end
	end


	listView.getItemAt = function(self, x, y)
		local index = math.floor(self.width /  ITEM_WIDTH) * (y - 1) + x

		if self.list[index] ~= nil then
			return index
		else
			return 0
		end
	end


	listView.onMouseClick = function(self, button, x, y)
		local mx = x
		local my = y

		y = y - 1 + self.offset - self.top
		x = x - self.left - 2

		if self.width - x > 8 then
			x = math.floor((x + 1) / ITEM_WIDTH)
			y = math.floor(y / ITEM_HEIGHT)

			if x > math.floor(self.width /  ITEM_WIDTH) - 0 then x = math.floor(self.width / ITEM_WIDTH) - 0 end

			x = x + 1
			y = y + 1
		else
			x = 0
			y = 0
		end

		--self.parent.name = x .. " " .. y .. " " .. math.floor(self.width /  ITEM_WIDTH)
		local item = self:getItemAt(x, y)
		--if item ~= nil then self.parent.name = item.name else self.parent.name = " " end
		if item ~= 0 then
			if self.isCtrlDown then
				table.insert(self.selectedList, item)
			else
				self.selectedList = { item }
			end
		else
			self.selectedList = {}
		end


		if button == 2 then
			if self.onContextMenu ~= nil then
				self:onContextMenu(item, mx, my)
			end
		end
	end


	--listView:reposition(listView.height, listView.width)
	return listView
end]])
table.insert(names, "/system/widgets/menuBar")
table.insert(values, [[
function Create(_parent, name)
	local menuBar = panel.Create(_parent, name)
	menuBar.items = {}


	menuBar.oldRefresh = menuBar.refresh
	menuBar.alignTop = true

	menuBar.refresh = function(self)
		self.width = self.parent:getCanvas().size.x
		self.height = 1
		
		if self.apignTop then
			self.top = 1
		end
		
		self.left = 0
		self.bgcolor = colors.white

		self.widgets = {}
		local totalWidth = 1


		for i, v in ipairs(self.items) do
			local width = string.len(v.name) + 2
			local item = label.Create(self, "label_" .. tostring(i))
			item.parent = self

			item.bgcolor = colors.white
			item.forecolor = colors.black
			item.forecolor2 = colors.red
			item.width = width
			item.left = totalWidth
			item.caption = v.name

			--item.onClick = function(sender)
			--	local a = menuBar.os.popupMenu(sender.menu, sender.left, sender.top + 1)
			--end
			item.onClick = v.onClick

			totalWidth = totalWidth + width
		end

		self:oldRefresh()
	end


	_parent.widgets[name] = menuBar
	_parent.lastZOrder = _parent.lastZOrder + 1
	menuBar.zOrder = _parent.lastZOrder
	return menuBar
end


function CreateItem(_name, _onClick)
	local item = {
		name = _name,
		onClick = _onClick,
	}

	return item
end]])
table.insert(names, "/system/widgets/paintBox")
table.insert(values, [[

function Create(_parent, name)
	local paintBox = {
		parent = _parent,
		left = 1,
		top = 1, 
		pheight = 0,
		pwidth = 0,
		height = 16,
		width = 24,
		bgcolor = colors.white,
		focused = false,
		visible = true,
		canvas = nil,
		widgets = {},
		brush = {
			bgcolor = colors.black,
			forecolor = colors.white,
			char = " ",
		},


		refresh = function(self)
			if self.canvas == nil then
				self.canvas = user.CreateCanvas(self.width - 1, self.height)
				self.canvas:fillrect(1, 1, self.width - 1, self.height, self.bgcolor)
				self.parent:getCanvas():draw(self.left, self.top, self.canvas)
			else
				if (self.pheight ~= self.height) or (self.pwidth ~= self.width) then
					local canvas = self.canvas
					self.canvas = user.CreateCanvas(self.width - 1, self.height)
					self.canvas:fillrect(1, 1, self.width - 1, self.height, self.bgcolor)
					self.canvas:draw(0, 0 --\[\[1\]\], canvas)
					self.canvas.effect = canvas.effect
				end

				self.parent:getCanvas():draw(self.left, self.top, self.canvas)
			end

			self.pheight = self.height
			self.pwidth = self.width
		end,


		mouseClick = function(self, button, x, y)
			--if self.onMouseClick ~= nil then self:onMouseClick(button, x - self.left, y - self.top) end
		end
	}

	_parent.widgets[name] = paintBox
	_parent.lastZOrder = _parent.lastZOrder + 1
	paintBox.zOrder = _parent.lastZOrder
	return paintBox
end]])
table.insert(names, "/system/widgets/panel")
table.insert(values, [[

function Create(_parent, name)
	local panel = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 16,
		width = 24,
		bgcolor = colors.white,
		focused = false,
		visible = true,
		align = "left",
		style = "none",
		canvas = nil,
		widgets = {},
		focusedWidget = nil,
		lastZOrder = 0,



		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local str = self.caption

			if self.parent.style ~= "none" then
				y = y + 1
			end

			self.canvas = user.CreateCanvas(self.width, self.height)
			self.canvas:fillrect(1, 1, self.width, self.height, self.bgcolor)

			if self.onBeforeRefresh ~= nil then
				self:onBeforeRefresh()
			end


			for k, v in pairs(self.widgets) do
				if self.focusedWidget == v then
					v.focused = true
				else
					v.focused = false

					if v.onRefresh ~= nil then
						v:onRefresh()
					end

					if v.visible == true then
						v:refresh()
					end
				end
			end

			--if self.parent.focusedWidget == self then
				if self.focusedWidget ~= nil then
					if self.focusedWidget.onRefresh ~= nil then
						self.focusedWidget:onRefresh()
					end

					self.focusedWidget:refresh()
				end
			--end

			if self.onRefresh ~= nil then
				self:onRefresh()
			end


			canvas:draw(self.left, self.top, self.canvas)
			canvas:setCursorPos(self.canvas.cursorPos.x + self.left, self.canvas.cursorPos.y + self.top)
			canvas.cursorBlink = self.canvas.cursorBlink
		end,


		mouseClick = function(self, button, x, y)
			self.focusedWidget = nil
			x = x - self.left + 0
			y = y - self.top -- 1

			for name, widget in pairs(self.widgets) do
				if (x >= widget.left) and (x < widget.left + widget.width) and 
				   (y >= widget.top) and (y < widget.top + widget.height) then
					self.focusedWidget = widget


					if widget.onMouseClick ~= nil then
						widget:onMouseClick(button, --\[\[x + self.left, y + self.top\]\]x + widget.left, y + widget.top)
					end

					if widget.mouseClick ~= nil then
						widget:mouseClick(button, --\[\[x + self.left, y + self.top\]\]x + widget.left, y + widget.top)
					end



					if button == 1 then
						if widget.onClick ~= nil then
							widget:onClick()
						end
					else
						if widget.onPopup ~= nil then
							widget:onPopup()
						end
					end
				end
			end
		end,


		keyPress = function(self, key, char)
			if self.focusedWidget ~= nil then
				if self.focusedWidget.keyPress ~= nil then
					self.focusedWidget:keyPress(key, char)
				end
			end
		end,


		getCanvas = function(self)
			return self.canvas
		end,
	}

	_parent.widgets[name] = panel
	_parent.lastZOrder = _parent.lastZOrder + 1
	panel.zOrder = _parent.lastZOrder
	return panel
end]])
table.insert(names, "/system/widgets/popupMenu")
table.insert(values, [[

function Create()
	local popupMenu = {
		canvas = nil,
		pleft = 1,
		ptop = 1,
		left = 1,
		top = 1,
		height = 0,
		width = 0,
		bgcolor = colors.white,
		forecolor = colors.black,
		forecolor2 = colors.red,
		focused = false,
		visible = true,
		showing = false,
		items = {},


		refresh = function(self)
			local canvas = self.canvas
			local items = self.items
			local x = self.left
			local y = self.top
			local maxWidth = 0



			if (self.showing) and (#items > 0) and (canvas ~= nil) then
				for k, v in pairs(items) do
					if string.len(v.text) > maxWidth then maxWidth = string.len(v.text) end
				end

				self.height = #items - 1
				self.width = maxWidth
				self.left = self.pleft

				if (canvas.size.y - self.ptop < self.height + 1) then
					canvas:fillrect(self.pleft + 1, self.ptop - self.height + 1, self.width, self.height, colors.black)
					canvas:fillrect(self.pleft, self.ptop - self.height, self.width, self.height, self.bgcolor)
					canvas.bgcolor = self.bgcolor
					canvas.forecolor = self.forecolor

					for i, v in ipairs(items) do
						canvas:setCursorPos(self.pleft, self.ptop - i + 1)
						--canvas:write(v.text)
						if v.text ~= "-" then
							canvas.forecolor = self.forecolor2
							canvas:write(string.sub(v.text, 1, 1))
							canvas.forecolor = self.forecolor
							canvas:write(string.sub(v.text, 2))
						else
							canvas.forecolor = colors.lightGray
							canvas:write(string.rep("-", self.width))
						end
					end

					self.top = self.ptop - self.height
				else
					canvas:fillrect(self.pleft + 1, self.ptop + 1, self.width, self.height, colors.black)
					canvas:fillrect(self.pleft, self.ptop, self.width, self.height, self.bgcolor)
					canvas.bgcolor = self.bgcolor
					canvas.forecolor = self.forecolor

					for i, v in ipairs(items) do
						canvas:setCursorPos(self.pleft, self.ptop + i - 1)

						if v.text ~= "-" then
							canvas.forecolor = self.forecolor2
							canvas:write(string.sub(v.text, 1, 1))
							canvas.forecolor = self.forecolor
							canvas:write(string.sub(v.text, 2))
						else
							canvas.forecolor = colors.lightGray
							canvas:write(string.rep("-", self.width))
						end
					end

					self.top = self.ptop
				end


			else
				self.showing = false
			end
		end,


		popUp = function(self, x, y)
			self.pleft = x
			self.ptop = y
			self.showing = true
		end,


		mouseClick = function(self, button, x, y)
			if (self.canvas.size.y - self.ptop < self.height + 1) then
				if (x >= self.left) and (x <= self.left + self.width) and (y >= self.top) and (y <= self.top + self.height) then
					local items = self.items
					local index = #items - (y - self.top - 0)

					if items[index] ~= nil then
						if items[index].onClick ~= nil then
							items[index]:onClick()
						end
					end
				end
			else
				if (x >= self.left) and (x <= self.left + self.width) and (y >= self.top) and (y <= self.top + self.height) then
					local items = self.items
					local index = y - self.top + 1

					if items[index] ~= nil then
						if items[index].onClick ~= nil then
							items[index]:onClick()
						end
					end
				end
			end

			self.showing = false
		end,
	}

	return popupMenu
end


function CreateItem(_text, _onClick)
	local item = {
		text = _text,
		onClick = _onClick,
	}

	return item
end]])
table.insert(names, "/system/widgets/progressBar")
table.insert(values, [[

function Create(_parent, name)
	local progressBar = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 1,
		width = 10,
		bgcolor = colors.white,
		forecolor = colors.black,
		fillcolor = colors.blue,
		showPercent = true,
		focused = false,
		visible = true,
		position = 0,
		max = 100,


		refresh = function(self)
			if self.position > self.max then self.position = self.max end
			if self.position < 0 then self.position = 0 end

			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local percent = math.ceil((100 * self.position) / self.max)
			local w = math.ceil((self.width * self.position) / self.max)
			local str = tostring(percent) .. "%"
			if w > self.width then w = self.width end
			if w < 0 then w = 0 end

			if self.parent.style ~= "none" then
				y = y + 1
			end

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, self.bgcolor)
			canvas:fillrect(self.left, y, w - 1, self.height - 1, self.fillcolor)

			x = self.left + math.floor(self.width / 2) - math.floor(string.len(str) / 2)

			if self.showPercent then
				canvas:setCursorPos(x, y)
				canvas.bgcolor = self.fillcolor
				canvas.forecolor = self.bgcolor
				canvas:write(str)
			end
		end
	}

	_parent.widgets[name] = progressBar
	_parent.lastZOrder = _parent.lastZOrder + 1
	progressBar.zOrder = _parent.lastZOrder
	return progressBar
end]])
table.insert(names, "/system/widgets/scrollBar")
table.insert(values, [[

function Create(_parent, name)
	local scrollBar = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 10,
		width = 1,
		value = 0,
		min = 0,
		max = 100,
		step = 10,
		focused = false,
		vertical = true,
		visible = true,


		refresh = function(self)
			local canvas = self.parent:getCanvas()
			local x = self.left
			local y = self.top
			local str = self.caption

			if self.parent.style ~= "none" then
				y = y + 1
			end

			canvas:fillrect(self.left, y, self.width - 1, self.height - 1, colors.white)

			if self.vertical == true then
				canvas:setCursorPos(x, y)
				canvas.bgcolor = colors.gray
				canvas.forecolor = colors.lightGray
				canvas:write("*")

				canvas:setCursorPos(x, y + self.height - 1)
				canvas.bgcolor = colors.gray
				canvas.forecolor = colors.lightGray
				canvas:write("*")

				local selPos = math.ceil((self.height - 2) * self.value / self.max)
				if selPos < 1 then selPos = 1 end
				if selPos > self.height - 2 then selPos = self.height - 2 end

				canvas:setCursorPos(x, y + selPos)
				canvas:write(" ")
			else
				canvas:setCursorPos(x, y)
				canvas.bgcolor = colors.gray
				canvas.forecolor = colors.lightGray
				canvas:write("*")

				canvas:setCursorPos(x + self.width - 1, y)
				canvas.bgcolor = colors.gray
				canvas.forecolor = colors.lightGray
				canvas:write("*")

				local selPos = math.ceil((self.width - 3) * self.value / self.max)
				if selPos < 1 then selPos = 1 end
				if selPos > self.width - 2 then selPos = self.width - 2 end

				canvas:setCursorPos(x + selPos, y)
				canvas:write(" ")
			end
		end,


		mouseDrag = function(self, button, x, y)
			if button == 1 then
				local delta = math.ceil((self.height - 2) / self.max) * x
				if self.vertical == true then
					delta = math.ceil((self.width - 2) / self.max) * y
				end

				self.value = self.value + delta
				if self.value < self.min then self.value = self.min end
				if self.value > self.max then self.value = self.max end

				self:refresh()
				if self.onChange ~= nil then
					self:onChange()
				end
			end
		end,


		mouseClick = function(self, button, x, y)
			if button == 1 then
				--\[\[local selPos = math.floor(self.height * self.value / self.max)
				if selPos < 1 then selPos = 1 end
				if selPos > self.height - 2 then selPos = self.height - 2 end
				local cx = self.left
				local cy = self.top

				if self.parent.style ~= "none" then
					cy = cy + 1
				end\]\]

				local cx = self.left
				local cy = self.top
				local oldValue = self.value
				local changed = false

				--if self.parent.style ~= "none" then
					cy = cy + 1
				--end

				if self.vertical == true then
					if y == cy then
						self.value = self.value - self.step
						changed = true
					end

					if y == cy + self.height - 1 then
						self.value = self.value + self.step
						changed = true
					end
				else
					if x == cx - 1 then
						self.value = self.value - self.step
						changed = true
					end

					if x == cx + self.width - 2 then
						self.value = self.value + self.step
						changed = true
					end
				end

				if self.value < self.min then self.value = self.min end
				if self.value > self.max then self.value = self.max end


				if (oldValue ~= self.value) and (self.onChange ~= nil) then self:onChange() end
			end
		end,
	}

	_parent.widgets[name] = scrollBar
	_parent.lastZOrder = _parent.lastZOrder + 1
	scrollBar.zOrder = _parent.lastZOrder
	return scrollBar
end]])
table.insert(names, "/system/widgets/shdocvw")
table.insert(values, [[function Create(_parent, name)
	local shdocvw = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 16,
		width = 24,
		focused = false,
		visible = true,
		canvas = nil,
		widgets = { },
		focusedWidget = nil,
		lastZOrder = 0,
		parsed = false,
		os = _parent.parent.os,
		url = "about:tabs",
		source = "",

		document = {
			activeElement = nil,

			paddingLeft = {
				[1] = 0,
			},

			blockWidth = {
			},


			style = {

			},

			size = {
				height = 0,
				width = 1,
			}
		},


		refresh = function(self)
			self.canvas = user.CreateCanvas(self.width, self.height)
			self.canvas:fillrect(1, 1, self.width, self.height, colors.white)

			if self.widgets.verticalBar == nil then
				self.widgets.verticalBar = scrollBar.Create(self, "verticalBar")
				self.widgets.verticalBar.step = 1

				self.widgets.verticalBar.onChange = function(sender)
					self.scroll.top = self.widgets.verticalBar.value
				end
			end

			self.widgets.verticalBar.left = self.width
			self.widgets.verticalBar.top = 0
			self.widgets.verticalBar.height = self.height

			self.document.size.width = self.width - 2

			if self.parsed == false then
				self:parse()
			end

			--self.canvas:draw(-self.scroll.left, -self.scroll.top, self.widgets.document)
			--self.widgets.document.left = -
			self:pageRender()


			self.widgets.verticalBar:refresh()
			self.parent:getCanvas():draw(self.left - 1, self.top, self.canvas)

			--self.parent.parent.os.setCaretPos(self.left + self.cursorPos.x, self.top + self.cursorPos.y)

			--\[\[if (self.cursorPos.x < self.width - 1) and (self.cursorPos.y - self.scroll.top < self.height) and (self.focused) then
				self.parent.parent.os.showCaret()
			else
				self.parent.parent.os.hideCaret()
			end\]\]
		end,


		setElementStyle = function(self, element, style)
			if self.document.style[style] ~= nil then
				if self.document.style[style].bgcolor ~= nil then element.bgcolor = self.document.style[style].bgcolor end
				if self.document.style[style].forecolor ~= nil then element.forecolor = self.document.style[style].forecolor end
				if self.document.style[style].align ~= nil then element.align = self.document.style[style].align end
				if self.document.style[style].height ~= nil then element.height = self.document.style[style].height end
				if self.document.style[style].width ~= nil then element.width = self.document.style[style].width end
				if self.document.style[style].paddingLeft ~= nil then element.left = element.left + self.document.style[style].paddingLeft end
				if self.document.style[style].paddingTop ~= nil then element.top = element.top + self.document.style[style].paddingTop end
			end
		end,


		loadPageFromFile = function(self, url)
			local file = fs.open(url, "r")
			local data = file.readAll()
			file.close()
			return data
		end,


		parse = function(self)
			self.document.blockWidth = { [1] = self.canvas.size.x }
			self.document.paddingLeft = { [1] = 0 }

			self.document.style = {
				text = {
					bgcolor = colors.white,
					forecolor = colors.black,
					align = "left",
					paddingLeft = 0,
				}
			}


			local webenv = {
				colors = colors,
				colours = colors,


				document = {
					location = self.url,
					client = "iDonkey 0.7a [Unstable]",
					size = {
						height = self.document.size.height,
						y = self.document.size.height,
						width = self.document.size.width,
						x = self.document.size.x,
					}
				},


				style = function(t)
					for k, v in pairs(t) do
						if self.document.style[k] == nil then self.document.style[k] = {} end

						if type(v) == "table" then
							if v.bgcolor ~= nil then self.document.style[k].bgcolor = v.bgcolor end
							if v.forecolor ~= nil then self.document.style[k].forecolor = v.forecolor end
							if v.align ~= nil then self.document.style[k].align = v.align end
							if v.height ~= nil then self.document.style[k].height = v.height end
							if v.width ~= nil then self.document.style[k].width = v.width end
							if v.paddingLeft ~= nil then self.document.style[k].paddingLeft = v.paddingLeft end
							if v.paddingTop ~= nil then self.document.style[k].paddingTop = v.paddingTop end
						end
					end
				end,


				text = function(id, class, str)
					local label = label.Create(self.document.activeElement or self, id)
					label.multiline = true
					label.caption = str
					label.left = (self.document.paddingLeft[#(self.document.paddingLeft)] or 0) + 1
					label.width = self.document.blockWidth[#(self.document.blockWidth)] or self.document.size.width - label.left
					label.top = self.document.size.height
					label.webclass = class

					self:setElementStyle(label, "text")
					self:setElementStyle(label, class)
					self:setElementStyle(label, id)

					--label:resize()
					self.document.size.height = label.top + label.height
				end,


				div = function(id, class, size)
					local div = panel.Create(self.document.activeElement or self, id)
					div.height = size.height or 2
					div.width = size.width or 10
					div.left = size.left or 2
					div.top = (size.top or 1) + self.document.size.height

					self:setElementStyle(div, "div")
					self:setElementStyle(div, class)
					self:setElementStyle(div, id)

					if not (size.float) then
						self.document.size.height = div.top + div.height
					end

					self.document.activeElement = div
				end,

				end_ = function()
					self.document.activeElement = self.document.activeElement.parent or self
					if self.document.activeElement == self then self.document.activeElement = nil end
				end,
			}


			local s = self:getTestPage()
			local page = loadstring(s)

			if page == nil then
				error("is nil!")
			end
			setfenv(page, webenv)

			local err = function(...)
				local s = ""

				for k, v in pairs(args) do
					s = s .. "v"
				end

				error(s)
			end

			xpcall(page, err)
			--page()
			self.parsed = true
			--error(self.widgets.greeting)
		end,


		pageRender = function(self)
			for k, v in pairs(self.widgets) do
				if k ~= "verticalBar" then
					v:refresh()
				end
			end
		end,


		getTestPage = function(self)
			local testPage = \[\[
				style({text = {bgcolor = colors.black, forecolor = colors.white, paddingLeft = 2, width = document.size.width - 3}})
				style({greeting = {forecolor = colors.lime}})

				--text("greeting", "greeting", "Hello, World!")
				--text("greeting2", "greeting", "Glad to meet you here.")
				--text("greeting3", "greeting", document.location)
				--text("greeting4", "greeting", document.client)

				style({mydivs = {bgcolor = colors.lime}})

				div("id", "mydivs")
					text("textindiv", "greeting", "I'm in dov now!")
				end_()
			\]\]

			return testPage
		end,


		getCanvas = function(self)
			return self.canvas
		end,
	}


	_parent.widgets[name] = shdocvw
	_parent.lastZOrder = _parent.lastZOrder + 1
	paintBox.zOrder = _parent.lastZOrder
	return shdocvw
end]])
table.insert(names, "/system/widgets/textArea")
table.insert(values, [[local MAXLENGTH = 255



function TextToAreaData(text)
	text = string.gsub(text, "\r", "")
	local areaData = {}
	local lines = user.split(text, "\n")

	for i, v in ipairs(lines) do
		local str = v

		if string.len(str) > MAXLENGTH then
			str = string.sub(str, 1, MAXLENGTH)
		elseif string.len(str) < MAXLENGTH then
			str = str .. "\r" .. string.rep(" ", MAXLENGTH - string.len(str) - 1)
		end

		areaData[i] = str
	end

	if #areaData == 0 then
		areaData = { "\0\r" .. string.rep(" ", MAXLENGTH - 2) }
	end

	return areaData
end



function AreaDataToText(areaData)
	local text = ""

	for i, v in ipairs(areaData) do
		local index = string.find(v, "\r")
		local str = v

		if index ~= nil then
			str = string.sub(v, 1, index - 1)
		end

		text = text .. str .. "\n"
	end

	return text
end


function PaintAreaData(canvas, areaData, scrollX, scrollY)
	for i, v in ipairs(areaData) do
		if (i - scrollY > 0) and (i <= scrollY + canvas.size.y) then
			local str = string.sub(v, scrollX, canvas.size.x)
			canvas:setCursorPos(1, i - scrollY)
			canvas:write(str)
		end
	end

	return canvas
end


function AreaLineLen(line)
	return string.find(line, "\r") or 0
end



function CreateEffect_HideSystemSymbols(parent)
	local effect = {
		parent = parent,
		selectedText = "",
		syntaxHighlighter = nil,


		getSelectedText = function(self)
			return string.gsub(string.gsub(self.selectedText, "\0", ""), "\r", "\n")
		end,


		isSelected = function(self, x, y)
			if (y + self.parent.scroll.top <= #(self.parent.areaData)) and (y + self.parent.scroll.top >= 1) and
				(x + self.parent.scroll.left - 1 < AreaLineLen(self.parent.areaData[y + self.parent.scroll.top])) then
				if self.parent.selection.endpos.y == self.parent.selection.startpos.y then
					if (y == self.parent.selection.startpos.y) and (x > self.parent.selection.startpos.x) and (x < self.parent.selection.endpos.x) then
						return true
					end
				else
					if (y >= self.parent.selection.startpos.y) and (y <= self.parent.selection.endpos.y) then
						if ((x > self.parent.selection.startpos.x) and (y == self.parent.selection.startpos.y)) or
							((x < self.parent.selection.endpos.x) and (y == self.parent.selection.endpos.y)) or
							((y > self.parent.selection.startpos.y) and (y < self.parent.selection.endpos.y)) then
							return true
						end
					end
				end
			end

			return false
		end,



		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			if self:isSelected(x, y) then
				return parent.selection.style.bgcolor
			else
				if self.syntaxHighlighter ~= nil then
					return self.syntaxHighlighter:getbgcolor(x, y, bgcolor, forecolor, char)
				else
					return bgcolor
				end
			end
		end,

		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			if self:isSelected(x, y) then
				return parent.selection.style.forecolor
			else
				if self.syntaxHighlighter ~= nil then
					return self.syntaxHighlighter:getforecolor(x, y, bgcolor, forecolor, char)
				else
					return forecolor
				end
			end
		end,

		getchar = function(self, x, y, bgcolor, forecolor, char)
			if self:isSelected(x, y) then
				self.selectedText = self.selectedText .. char
			end

			if char == "\0" then
				return " "
			elseif char == "\r" then
				return " " --^
			else
				if self.syntaxHighlighter ~= nil then
					return self.syntaxHighlighter:getchar(x, y, bgcolor, forecolor, char)
				else
					return char
				end
			end
		end,
	}

	return effect
end




function Create(_parent, name, widgets)
	local textArea = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 16,
		width = 24,
		bgcolor = colors.white,
		forecolor = colors.black,
		focused = false,
		visible = true,
		canvas = nil,
		text = "", lastText = "",
		tab = 0,
		editable = true,
		--scrollBars = "both",  --"horisontal", "vertical", "both"
		scroll = { left = 1, top = 0},
		buffer = nil,
		widgets = { },
		widgetsLib = widgets,
		focusedWidget = nil,
		lastZOrder = 0,
		cursorPos = { x = 0, y = 1, text = 1},
		--textBuffer = { { {  } } }.
		linesLength = nil,
		areaData = {},
		syntaxHighlighter = nil,


		selection = {
			startpos = { x = 1, y = 1 },
			endpos = { x = 1, y = 1 },

			style = {
				bgcolor = colors.blue,
				forecolor = colors.white,
			},
		},



		getText = function(self)
			return string.gsub(self.text, "\0", "")
		end,


		setText = function(self, text)
			text = string.gsub(text, "\n", "\0\n")
			self.text = text or ""
			self.buffer = nil
		end,


		getSelectedText = function(self)
			if self.buffer ~= nil then
				return self.buffer.effect:getSelectedText()
			else
				return ""
			end
		end,



		refresh = function(self, refreshSyntax)
			self.canvas = user.CreateCanvas(self.width, self.height)
			self.canvas:fillrect(1, 1, self.width, self.height, self.bgcolor)
			if self.scroll.left < 2 then self.scroll.left = 1 end



			if self.widgets.verticalBar == nil then
				self.widgets.verticalBar = scrollBar.Create(self, "verticalBar")
				self.widgets.verticalBar.step = 1

				self.widgets.verticalBar.onChange = function(sender)
					self.scroll.top = self.widgets.verticalBar.value
					self.buffer = nil
				end
			end

			self.widgets.verticalBar.left = self.width
			self.widgets.verticalBar.top = 0
			self.widgets.verticalBar.height = self.height - 1



			if self.widgets.horisontalBar == nil then
				self.widgets.horisontalBar = scrollBar.Create(self, "horisontalBar")
				self.widgets.horisontalBar.step = 1
				self.widgets.horisontalBar.min = 1
				self.widgets.horisontalBar.value = 2
				self.widgets.horisontalBar.vertical = false

				self.widgets.horisontalBar.onChange = function(sender)
					self.scroll.left = self.widgets.horisontalBar.value
					if self.scroll.left < 2 then self.scroll.left = 1 end
					self.buffer = nil
				end
			end

			self.widgets.horisontalBar.left = 1
			self.widgets.horisontalBar.top = self.height - 1
			self.widgets.horisontalBar.height = 1
			self.widgets.horisontalBar.width = self.width - 1


			if refreshSyntax then self.buffer = nil end

			if self.buffer == nil then
				self.buffer = user.CreateCanvas(--\[\[self.width - 1\]\]256, self.height - 1)
				self.buffer.bgcolor = self.bgcolor
				self.buffer.forecolor = self.forecolor
				self.buffer.autoScroll = true
				self.buffer.effect = CreateEffect_HideSystemSymbols(self)
				self.buffer.effect.syntaxHighlighter = self.syntaxHighlighter
				self.buffer:clear()

				self.areaData = TextToAreaData(self.text)

				if self.syntaxHighlighter then
					self.syntaxHighlighter:setScrolling(self.scroll)
					if refreshSyntax then self.syntaxHighlighter:parseAreaData(self.areaData, self.forecolor, self.buffer.size.x, self.buffer.size.y) end
				end

				self.buffer = PaintAreaData(self.buffer, self.areaData, self.scroll.left, self.scroll.top)


				self.widgets.horisontalBar.max = 255
				self.widgets.verticalBar.max = #(self.areaData) - self.height + 1
				if self.widgets.verticalBar.max < 0 then self.widgets.verticalBar.max = 0 end
			end

			self.canvas:draw(0, 0, self.buffer)


			self.widgets.verticalBar:refresh()
			self.widgets.horisontalBar:refresh()
			self.parent:getCanvas():draw(self.left - 1, self.top, self.canvas)
			self.parent:getCanvas():setCursorPos(self.left + self.width - 1, self.top + self.height)
			self.parent:getCanvas().bgcolor = self.parent.bgcolor
			self.parent:getCanvas():write(" ")

			self.parent.parent.os.setCaretPos(self.left + self.cursorPos.x - self.scroll.left + 1, self.top + self.cursorPos.y - self.scroll.top)
			self.parent.parent.os.setCaretColor(self.forecolor)


			if (self.cursorPos.x - self.scroll.left + 1 >= 0) and (self.cursorPos.y - self.scroll.top > 0) and
				(self.cursorPos.x - self.scroll.left + 1 < self.width - 1) and (self.cursorPos.y - self.scroll.top < self.height)
				and (self.focused) then
				self.parent.parent.os.showCaret()
			else
				self.parent.parent.os.hideCaret()
			end
		end,



		getCanvas = function(self)
			return self.canvas
		end,


		mouseDrag = function(self, button, x, y)
			x = x - self.left + 1
			y = y - self.top

			self.selection.endpos = {x = x, y = y}
			if self.canvas.buffer ~= nil then self.canvas.buffer.effect.selectedText = "" end
		end,


		mouseClick = function(self, button, x, y)
			x = x - self.left
			y = y - self.top


			if button == 2 then
				local menu = self.widgetsLib.PopupMenu.Create()
				menu.bgcolor = colors.lightGray
				menu.tag = self

				table.insert(menu.items, self.widgetsLib.PopupMenu.CreateItem("Copy", 
					function(sender)
						menu.tag.parent.parent.os.copyToClipboard(menu.tag:getSelectedText(), "TEXT")
				end))

				table.insert(menu.items, self.widgetsLib.PopupMenu.CreateItem("Paste", 
					function(sender)
						local text = menu.tag.parent.parent.os.pasteFromClipboard("TEXT")

						if text ~= nil then
							local self = sender.tag

							if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
							local pre = string.sub(self.areaData[self.cursorPos.y], 1, self.cursorPos.x)
							local post = string.sub(self.areaData[self.cursorPos.y], self.cursorPos.x + 1, string.len(self.areaData[self.cursorPos.y]) - string.len(pre))

							self.areaData[self.cursorPos.y] = pre .. text .. post
							self.areaData[self.cursorPos.y] = string.gsub(self.areaData[self.cursorPos.y], "\0", "")
							self.cursorPos.x = self.cursorPos.x + 1


							self.text = AreaDataToText(self.areaData)
							self.buffer = nil
						end
				end))

				--self.widgetsLib.popupMenu(menu, x + self.left + 1, y + self.top + 1)
			else
				self.selection.startpos.x = x
				self.selection.startpos.y = y
				self.selection.endpos = {x = 1, y = 1}
				if self.canvas.buffer ~= nil then self.canvas.buffer.effect.selectedText = "" end
			end


			if (x == self.width - 1) or (y == self.height) then
				if self.widgets.verticalBar.mouseClick ~= nil then
					self.widgets.verticalBar:mouseClick(button, x, y)
				end

				if self.widgets.verticalBar.onMouseClick ~= nil then
					self.widgets.verticalBar:onMouseClick(button, x, y)
				end

				if self.widgets.horisontalBar.mouseClick ~= nil then
					self.widgets.horisontalBar:mouseClick(button, x, y)
				end

				if self.widgets.horisontalBar.onMouseClick ~= nil then
					self.widgets.horisontalBar:onMouseClick(button, x, y)
				end
			else
				if self.editable then
					self.cursorPos.x = x + self.scroll.left - 1
					self.cursorPos.y = y + self.scroll.top
				end
			end

			if self.cursorPos.y > #(self.areaData) then self.cursorPos.y = #(self.areaData) end
			if self.cursorPos.y < 1 then self.cursorPos.y = 0 end
			if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) - 1 then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
			if self.cursorPos.x < 0 then self.cursorPos.x = 0 end
		end,



		keyPress = function(self, key, char)
			self.selection.endpos = {x = 1, y = 1}

			if self.editable then
				if key == keys.right then
					self.cursorPos.x = self.cursorPos.x + 1
					self.buffer = nil
				elseif key == keys.left then
					self.cursorPos.x = self.cursorPos.x - 1
					self.buffer = nil
				elseif key == keys.up then
					self.cursorPos.y = self.cursorPos.y - 1
					self.buffer = nil
				elseif key == keys.down then
					self.cursorPos.y = self.cursorPos.y + 1
					self.buffer = nil
				elseif key == keys.enter then

					if self.cursorPos.x == 0 then
						local str = self.areaData[self.cursorPos.y]
						self.areaData[self.cursorPos.y] = "\0\r" .. string.rep(" ", MAXLENGTH - 2)

						table.insert(self.areaData, self.cursorPos.y + 1, str)
						self.cursorPos.y = self.cursorPos.y + 1
						self.cursorPos.x = 0
					else
						local str = string.sub(self.areaData[self.cursorPos.y], self.cursorPos.x + 1, AreaLineLen(self.areaData[self.cursorPos.y]))
						str = string.gsub(str, "\r", "")

						if string.len(str) > MAXLENGTH then str = string.sub(str, 1, MAXLENGTH) end
						if string.len(str) < MAXLENGTH then str = str .. "\r" .. string.rep(" ", MAXLENGTH - string.len(str) - 1) end

						self.areaData[self.cursorPos.y] = string.sub(self.areaData[self.cursorPos.y], 1, self.cursorPos.x)
						local parts = user.split(self.areaData[self.cursorPos.y], "\r")
						self.areaData[self.cursorPos.y] = parts[1] .. "\r" .. string.rep(" ", MAXLENGTH - string.len(parts[1]) - 1)

						if user.stringstarts(str, "\r") then
							str = "\0" .. string.sub(str, 1, string.len(str) - 1)
						end

						table.insert(self.areaData, self.cursorPos.y + 1, str)
						self.cursorPos.y = self.cursorPos.y + 1
						self.cursorPos.x = 0
					end

					self.text = AreaDataToText(self.areaData)
					self.buffer = nil

				elseif key == keys.backspace then
					local proc = function() 
						if (self.cursorPos.x >= 1) then
							if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
							local pre = string.sub(self.areaData[self.cursorPos.y], 1, self.cursorPos.x - 1)
							local post = string.sub(self.areaData[self.cursorPos.y], self.cursorPos.x + 1, string.len(self.areaData[self.cursorPos.y]) - string.len(pre))

							self.areaData[self.cursorPos.y] = pre .. post
							self.cursorPos.x = self.cursorPos.x - 1
						else
							if #(self.areaData) > 1 then
								if (self.cursorPos.x >= 1) and (self.cursorPos.y < #(self.areaData)) then
									local pre = string.sub(self.areaData[self.cursorPos.y - 1], 1, AreaLineLen(self.areaData[self.cursorPos.y - 1]) - 1)
									local post = string.sub(self.areaData[self.cursorPos.y], 1, AreaLineLen(self.areaData[self.cursorPos.y]) - 1)
									pre = string.gsub(pre, "\0", "")

									self.areaData[self.cursorPos.y - 1] = pre .. post .. "\r" .. string.rep(" ", MAXLENGTH - 1 - string.len(pre) - string.len(post))
									table.remove(self.areaData, self.cursorPos.y)
									self.cursorPos.y = self.cursorPos.y - 1
									self.cursorPos.x = MAXLENGTH - AreaLineLen(self.areaData[self.cursorPos.y]) - 1
								elseif (self.cursorPos.y == #(self.areaData)) and (self.cursorPos.x <= 1) then
									if AreaLineLen(self.areaData[self.cursorPos.y]) < 1 then
										table.remove(self.areaData, self.cursorPos.y)
										self.cursorPos.y = self.cursorPos.y - 1
									else
										local pre = string.sub(self.areaData[self.cursorPos.y - 1], 1, AreaLineLen(self.areaData[self.cursorPos.y - 1]) - 1)
										local post = string.sub(self.areaData[self.cursorPos.y], 1, AreaLineLen(self.areaData[self.cursorPos.y]) - 1)
										pre = string.gsub(pre, "\0", "")

										self.areaData[self.cursorPos.y - 1] = pre .. post .. "\r" .. string.rep(" ", MAXLENGTH - 1 - string.len(pre) - string.len(post))
										table.remove(self.areaData, self.cursorPos.y)
										self.cursorPos.y = self.cursorPos.y - 1
										self.cursorPos.x = MAXLENGTH - AreaLineLen(self.areaData[self.cursorPos.y]) - 1
									end
								end
							end
						end
					end

					pcall(proc)

					self.text = AreaDataToText(self.areaData)
					self.buffer = nil

				elseif key == keys.delete then

					if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
					local pre = string.sub(self.areaData[self.cursorPos.y], 1, self.cursorPos.x)
					local post = string.sub(self.areaData[self.cursorPos.y], self.cursorPos.x + 2, string.len(self.areaData[self.cursorPos.y]) - string.len(pre))

					self.areaData[self.cursorPos.y] = pre .. post

					self.text = AreaDataToText(self.areaData)
					self.buffer = nil

				elseif char ~= "" then

					if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
					local pre = string.sub(self.areaData[self.cursorPos.y], 1, self.cursorPos.x)
					local post = string.sub(self.areaData[self.cursorPos.y], self.cursorPos.x + 1, string.len(self.areaData[self.cursorPos.y]) - string.len(pre))

					self.areaData[self.cursorPos.y] = pre .. char .. post
					self.areaData[self.cursorPos.y] = string.gsub(self.areaData[self.cursorPos.y], "\0", "")
					self.cursorPos.x = self.cursorPos.x + 1


					self.text = AreaDataToText(self.areaData)
					self.buffer = nil
				end


				if self.cursorPos.y > #(self.areaData) then self.cursorPos.y = #(self.areaData) end
				if self.cursorPos.y < 1 then self.cursorPos.y = 0 end
				if self.cursorPos.x > AreaLineLen(self.areaData[self.cursorPos.y]) then self.cursorPos.x = AreaLineLen(self.areaData[self.cursorPos.y]) - 1 end
				if self.cursorPos.x < 0 then self.cursorPos.x = 0 end

				--if AreaLineLen(self.areaData[self.cursorPos.y]) <= 0 then
				--	self.cursorPos.y = self.cursorPos.y - 1
				--end

				self.scroll.left = self.cursorPos.x - self.width + 2
				if self.scroll.left < 0 then self.scroll.left = 0 end
				self.widgets.horisontalBar.value = self.scroll.left

				self.scroll.top = self.cursorPos.y - self.height + 1
				if self.scroll.top < 0 then self.scroll.top = 0 end
				self.widgets.verticalBar.value = self.scroll.top



				self:refresh()
			end
		end,


	}

	_parent.widgets[name] = textArea
	_parent.lastZOrder = _parent.lastZOrder + 1
	textArea.zOrder = _parent.lastZOrder
	return textArea
end]])
table.insert(names, "/system/widgets/textView")
table.insert(values, [[function Create(_parent, name)
	local textArea = {
		parent = _parent,
		left = 1,
		top = 1, 
		height = 16,
		width = 24,
		bgcolor = colors.white,
		forecolor = colors.black,
		focused = false,
		visible = true,
		canvas = nil,
		text = "", lastText = "",
		tab = 0,
		editable = false,
		--scrollBars = "both",  --"horisontal", "vertical", "both"
		scroll = { left = 0, top = 0},
		buffer = nil,
		widgets = { },
		focusedWidget = nil,
		lastZOrder = 0,
		cursorPos = { x = 1, y = 1, text = 1},


		refresh = function(self)
			self.canvas = user.CreateCanvas(self.width, self.height)
			self.canvas:fillrect(1, 1, self.width, self.height, self.bgcolor)

			if self.widgets.verticalBar == nil then
				self.widgets.verticalBar = scrollBar.Create(self, "verticalBar")
				self.widgets.verticalBar.step = 1

				self.widgets.verticalBar.onChange = function(sender)
					self.scroll.top = self.widgets.verticalBar.value
				end
			end

			self.widgets.verticalBar.left = self.width
			self.widgets.verticalBar.top = 0
			self.widgets.verticalBar.height = self.height


			if (self.text ~= self.lastText) or (self.buffer == nil) then
				self.buffer = user.CreateCanvas(self.width - 1, 1)
				self.buffer:fillrect(1, 1, 1, 1, self.bgcolor)
				self.buffer.bgcolor = self.bgcolor
				self.buffer.forecolor = self.forecolor

				if (self.text ~= nil) and string.len(self.text) > 0 then
					local lines = user.split(self.text, "\n")
					local lastY = self.buffer.cursorPos.y

					for i, v in ipairs(lines) do
						self:printLine(v)
					end

					self.widgets.verticalBar.max = self.buffer.cursorPos.y - lastY - self.height + 1
					if self.widgets.verticalBar.max < 0 then self.widgets.scrollBar.max = 0 end

					self.canvas:draw(-self.scroll.left, -self.scroll.top, self.buffer)
				end

				self.lastText = self.text
			else
				self.canvas:draw(-self.scroll.left, -self.scroll.top, self.buffer)
			end

			self.widgets.verticalBar:refresh()
			self.parent:getCanvas():draw(self.left - 1, self.top, self.canvas)

			self.parent.parent.os.setCaretPos(self.left + self.cursorPos.x, self.top + self.cursorPos.y)

			if (self.cursorPos.x < self.width - 1) and (self.cursorPos.y - self.scroll.top < self.height) and (self.focused) then
				self.parent.parent.os.showCaret()
			else
				self.parent.parent.os.hideCaret()
			end
		end,


		printLine = function(self, line)
			--self.buffer:write()
			if string.len(line) > 0 then
				if self.buffer.cursorPos.y > 1 then
					self.buffer.cursorPos.x = 1
					self.buffer.cursorPos.y = self.buffer.cursorPos.y + 1
				end


				line = string.gsub(line, "  ", "\2\2")
				local words = user.split(line, " ")

				for i, v in ipairs(words) do
					if self.buffer.cursorPos.x + string.len(v) + 1 > self.width then
						self.buffer.cursorPos.x = 1 + self.tab
						self.buffer.cursorPos.y = self.buffer.cursorPos.y + 1
					end

					if self.buffer.cursorPos.y > self.buffer.size.y then
						local lastSize = self.buffer.size.y
						self.buffer.size.y = self.buffer.cursorPos.y + 1--self.buffer.size.y + 1

						for y = lastSize + 1, self.buffer.size.y do
							self.buffer.data[y] = {}

							for x = 1, self.buffer.size.x do
								self.buffer.data[y][x] = {}

								self.buffer.data[y][x].bgcolor = self.bgcolor
								self.buffer.data[y][x].forecolor = self.forecolor
								self.buffer.data[y][x].char = " "
							end
						end
					end

					self.buffer:write(string.gsub(v, "\2\2", "  ") .. " ")
				end

				self.buffer.cursorPos.x = self.buffer.cursorPos.x - 1
			end
		end,


		getCanvas = function(self)
			return self.canvas
		end,


		mouseClick = function(self, button, x, y)
			x = x - self.left
			y = y - self.top

			if x == self.width - 1 then
				if self.widgets.verticalBar.mouseClick ~= nil then
					self.widgets.verticalBar:mouseClick(button, x, y)
				end

				if self.widgets.verticalBar.onMouseClick ~= nil then
					self.widgets.verticalBar:onMouseClick(button, x, y)
				end
			else
				if self.editable then
					self.cursorPos.x = x
					self.cursorPos.y = y + self.scroll.top
					self.cursorPos.text = self:getTextPosFromCPos(x, y + self.scroll.top)
				end
			end
		end,


		keyPress = function(self, key, char)
			if self.editable then
				if key == keys.right then
					self.cursorPos.text = self.cursorPos.text + 1
				elseif key == keys.left then
					self.cursorPos.text = self.cursorPos.text - 1
				elseif key == keys.down then
					self.cursorPos.text = self.cursorPos.text + self.width - 1
				elseif key == keys.up then
					self.cursorPos.text = self.cursorPos.text - self.width + 1
				elseif key == keys.enter then
					local textBegin = string.sub(self.text, 1, self.cursorPos.text)
					local textEnd = string.sub(self.text, self.cursorPos.text + 1, string.len(self.text))

					self.text = textBegin .. "\n" .. textEnd
					self.cursorPos.text = self.cursorPos.text + (self.width - self.cursorPos.y) - 1
					self.buffer = nil
				else
					local textBegin = string.sub(self.text, 1, self.cursorPos.text)
					local textEnd = string.sub(self.text, self.cursorPos.text + 1, string.len(self.text))

					self.text = textBegin .. char .. textEnd
					self.cursorPos.text = self.cursorPos.text + string.len(char)
					self.buffer = nil
				end


				local x, y = self:recalculateCursorPos()
				--self.cursorPos.x = x
				--self.cursorPos.y = y

				self:refresh()
			end
		end,


		recalculateCursorPos = function(self)

		end,


		getTextPosFromCPos = function(self, cx, cy)
			local lines = user.split(self.text, "\n")
			local index = 0
			local lineWidths = {}

			for i, line in ipairs(lines) do
				line = string.gsub(line, "  ", "\2\2")
				local words = user.split(line, " ")
				index = index + 1
				lineWidths[index] = 0

				for j, word in ipairs(words) do
					if lineWidths[index] > self.width - 1 then
						index = index + 1
						lineWidths[index] = 0
					end
				end
			end

			local textY = 0
			for i = 1, cy do
				textY = textY + lineWidths[i]
			end

			local textX = textY + cx
			return textX
		end,




		recalculateCursorPos2 = function(self)
			local lines = user.split(self.text, "\n")
			local lineWidths = {}
			local index = 0
			local textLen = 0
			local yPos = 0
			local ySet = false

			for i, line in ipairs(lines) do
				line = string.gsub(line, "  ", "\2\2")
				local words = user.split(line, " ")
				index = index + 1
				lineWidths[index] = 0

				for j, word in ipairs(words) do
					if lineWidths[index] > self.width - 1 then
						index = index + 1
						lineWidths[index] = 0
					end

					lineWidths[index] = lineWidths[index] + string.len(word) + 1
					textLen = textLen + string.len(word) + 1

					if ySet == false and textLen > self.cursorPos.text then
						ySet = true
						yPos = index
					end
				end
			end

			local y = math.floor(self.cursorPos.text / (self.width - 1))
			local textPos = 0

			for i = 1, y do
				textPos = textPos + lineWidths[y]
			end

			--local y = math.floor(self.cursorPos.text / (self.width - 1))
			local y = yPos
			local cx = self.cursorPos.text - textPos
			local cy = y + 1

			--return cx, cy
			return 1, 1
		end,



	}

	_parent.widgets[name] = textArea
	_parent.lastZOrder = _parent.lastZOrder + 1
	textArea.zOrder = _parent.lastZOrder
	return textArea
end








--\[\[
										--if (absPos - string.len(word) - 1 > self.cursorPos.text) and (absPos + string.len(word) + 1 < self.cursorPos.text) then
					--	return cx + absPos + string.len(word) + 1 - self.cursorPos.text, cy
					--end

					xoffset = xoffset + string.len(word) + 1
					absPos = absPos + string.len(word) + 1

					if xoffset > self.width - 1 then
						xoffset = self.tab
						yoffset = yoffset + 1
					end\]\]]])
table.insert(names, "/system2/app.pic")
table.insert(values, [[pic|3|4|b0 b0 b0 b0 f0 f0 f0 f0 f0 f4af4pf4p]])
table.insert(names, "/system2/desktop.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local desktop = form.Create("Desktop")
local lastTime = 0



app.canvas.effect = {
	getbgcolor = function(self, x, y, bgcolor, forecolor, char)
		if (y == 1) or (x == app.canvas.size.x) then
			return config.DESKTOP_COLOR
		else
			return bgcolor
		end
	end,

	getforecolor = function(self, x, y, bgcolor, forecolor, char)
		return forecolor
	end,

	getchar = function(self, x, y, bgcolor, forecolor, char)
		if (y == 1) or (x == app.canvas.size.x) then
			return " "
		else
			return char
		end
	end,
}



app:addForm(desktop, "Desktop")
desktop:show()
desktop.bgcolor = config.DESKTOP_COLOR
desktop.controlBox = false
desktop.drawTitle = false

os.getProcessInfo(os.getCurrentProcess()).showInTaskbar = false

desktop.onTerminate = function(sender)
	return false
end


local listView = widgets.FileListView.Create(desktop, "listView")
listView.bgcolor = config.DESKTOP_COLOR
listView.top = 1
listView.left = 1
listView.width = app.canvas.size.x
listView.height = app.canvas.size.y - 1
listView.path = os.getSystemPath() .. "/userdata/Desktop"
listView.widgets.scrollBar.visible = false
listView:refreshList()

listView.onClick = function(sender)
	local time = os.time()

	if (time - lastTime) * 10 < config.PROCESS_TIMER then
		local selected = listView.selectedList
		if #selected > 0 then
			--listView:navigate(listView.list[selected[1\]\].name)
			--listView.selectedList = {}
			if listView.list[selected[1\]\].dir then
				os.shell.run("explorer \"" .. listView.path .. "/" .. listView.list[selected[1\]\].name .. "\"")
			else
				local fileName = string.gsub("home:/" .. listView.path .. "/" .. listView.list[selected[1\]\].name, "//", "/")
				os.shell.run(fileName)
			end
		end
	end

	lastTime = time
end



--for i=1,100 do
	--table.insert(listView.list, { icon = {}, name = "Tst" .. i .. ".app" })
	--table.insert(listView.list, { icon = {}, name = "Brian Griffin" })
--end


os.startTimer(2, function() 
	listView:refreshList()
	desktop:refresh()
end )
app:run()]])
table.insert(names, "/system2/exec.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Run...")
app:addForm(mainForm, "Run...")
mainForm:show()


local txtCmd = widgets.Edit.Create(mainForm, "txtCmd")
txtCmd.left = 2
txtCmd.top = 5
txtCmd.width = app.canvas.size.x - 2
txtCmd.text = ""


local btnCmd = widgets.Button.Create(mainForm, "btnCmd")
btnCmd.width = 9
btnCmd.left = app.canvas.size.x - btnCmd.width
btnCmd.top = app.canvas.size.y - 2
btnCmd.caption = " Run"

btnCmd.onClick = function(sender)
	if (txtCmd.text == nil) or (txtCmd.text == "") then
		os.messageBox("message", "Please specify any command.", "Error", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
		}, "defText")
	else
		os.shell.run(txtCmd.text)
		app:terminate()
	end
end



local lblExec = widgets.Label.Create(mainForm, "lblExec")
lblExec.left = 2
lblExec.top = 2
lblExec.caption = "Type the name of a program, folder or document"-- and it will be opened."
lblExec.width = app.canvas.size.x - 2
lblExec.height = 1

local lblExec = widgets.Label.Create(mainForm, "lblExec2")
lblExec.left = 2
lblExec.top = 3
lblExec.caption = "and it will be opened."
lblExec.width = app.canvas.size.x - 2
lblExec.height = 1

local lblExec = widgets.Label.Create(mainForm, "lblExec3")
lblExec.left = 2
lblExec.top = 7
lblExec.caption = "Built-in commands:"
lblExec.width = app.canvas.size.x - 2
lblExec.height = 1

local lblExec = widgets.Label.Create(mainForm, "lblExec4")
lblExec.left = 5
lblExec.top = 9
lblExec.caption = "exec   explorer   lnkcreate   paintbrush" --   procman   winver
lblExec.width = app.canvas.size.x - 8
lblExec.height = 1
lblExec.forecolor = colors.gray

local lblExec = widgets.Label.Create(mainForm, "lblExec5")
lblExec.left = 5
lblExec.top = 11
lblExec.caption = "procman   winver"
lblExec.width = app.canvas.size.x - 8
lblExec.height = 1
lblExec.forecolor = colors.gray



app:run()]])
table.insert(names, "/system2/explorer.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local desktop = form.Create("Explorer")
local lastTime = 0
local lastPlacesTime = 0
local lastSearchTime = 0

local showPlaces = true
local showSearch = false


local frmWarning = form.Create("Warning")
app:addForm(frmWarning, "Warning")
frmWarning.controlBox = false


app:addForm(desktop, "Explorer")
desktop:show()
desktop.bgcolor = colors.white


desktop.onTerminate = function(sender)
	--return false
	return true
end



local lblWarning = widgets.Label.Create(frmWarning, "lblWarning")
lblWarning.left = 2
lblWarning.top = 2
lblWarning.width = app.canvas.size.x - 4
lblWarning.caption = "The following files were not copied:"

local lstWarning = widgets.ListBox.Create(frmWarning, "lstWarning")
lstWarning.top = 4
lstWarning.left = 0
lstWarning.width = app.canvas.size.x + 1
lstWarning.height = app.canvas.size.y - 4 - 3

local btnWarning = widgets.Button.Create(frmWarning, "btnWarning")
btnWarning.width = 9
btnWarning.left = app.canvas.size.x - btnWarning.width
btnWarning.top = app.canvas.size.y - 2
btnWarning.caption = "OK"

btnWarning.onClick = function(sender)
	desktop:show()
	os.sendMessage(hwnd, {msg = "refresh"})
end





local listView = widgets.FileListView.Create(desktop, "listView")
listView.bgcolor = colors.white
listView.top = 1 + 3 + 1
listView.left = 1
listView.width = app.canvas.size.x
listView.height = app.canvas.size.y - 1 - 3 - 1
--listView.top = 2
--listView.left = 1
--istView.width = app.canvas.size.x
--listView.height = app.canvas.size.y - 2

listView.path = "home:/"
listView:refreshList()

listView.onClick = function(sender)
	listView.isCtrlDown = app:isCtrlDown()

	local time = os.time()

	if (time - lastTime) * 10 < config.PROCESS_TIMER then
		local selected = listView.selectedList
		if #selected > 0 then
			--listView:navigate(listView.list[selected[1\]\].name, true, os)
			--listView.selectedList = {}
			if listView.list[selected[1\]\].dir then
				listView:navigate(listView.list[selected[1\]\].name, true, os)
				listView.selectedList = {}
			else
				local fileName = string.gsub("home:/" .. listView.path .. "/" .. listView.list[selected[1\]\].name, "//", "/")
				os.shell.run(fileName)
			end
		end
	end

	lastTime = time
end

listView.onNavigate = function(sender, path)
	sender.parent.widgets["Panel"].widgets["AddressBar"].text = path
	sender.selectedList = {}
end

listView.onContextMenu = function(sender, item, x, y)
	local menu = widgets.PopupMenu.Create()
	--menu.bgcolor = colors.lightGray
	menu.tag = item
	table.insert(menu.items, widgets.PopupMenu.CreateItem("Open", function(sender) listView:navigate(menu.tag.name, true, os) end))
	table.insert(menu.items, widgets.PopupMenu.CreateItem("-", nil))
	table.insert(menu.items, widgets.PopupMenu.CreateItem("Open containing folder", function(sender) os.shell.run("explorer \"" .. sender.path .. "\"") end))

	--widgets.popupMenu(menu, x + 1, y + 1)
end



local panel = widgets.Panel.Create(desktop, "Panel")
panel.top = 2
panel.left = 0
panel.width = app.canvas.size.x
panel.height = 3
panel.bgcolor = colors.lightGray


local backButton = widgets.Button.Create(panel, "BackButton")
backButton.left = 2
backButton.top = 2
backButton.height = 1
backButton.width = 9
backButton.forecolor2 = colors.white
backButton.align = "center"
backButton.caption = " <- Back"

backButton.onClick = function(sender)
	listView:goBack()
end


local addressBar = widgets.Edit.Create(panel, "AddressBar")
addressBar.left = 2 + 9 + 1
addressBar.top = 2
addressBar.height = 1
addressBar.width = app.canvas.size.x - 2 - 9 - 1 - 5
addressBar.text = "home:/"

addressBar.onRefresh = function(sender)
	sender.text = string.gsub(sender.text, "%/%/", "%/")
end



local goButton = widgets.Button.Create(panel, "GoButton")
goButton.left = 2 + 9 + 1 + addressBar.width + 1
goButton.top = 2
goButton.height = 1
goButton.width = 4
goButton.forecolor2 = colors.white
goButton.align = "center"
goButton.caption = " Go"

goButton.onClick = function(sender)
	if addressBar.text:find("home:/") then
		listView:navigate(addressBar.text)
	else
		listView:navigate("home:/" .. addressBar.text)
	end
end


local function OpenWithText(fname)
	local p = user.split(fname, ".")

	if #p == 1 then
		return "Run in Emulator"
	elseif string.lower(p[#p]) == "app" then
		return "Run"
	else
		return "Open"
	end
end


local fileMenu = widgets.PopupMenu.Create()
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New...", function(sender)
		os.messageBox("input", "New file name:", "Create File...", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					local fileName = sender.parent.widgets.edit.text

					if string.find(fileName, "%/") or string.find(fileName, "%\\") or
						string.find(fileName, "%:") or string.find(fileName, "%*") or
						string.find(fileName, "%?") or string.find(fileName, "%\"") or
						string.find(fileName, "%<") or string.find(fileName, "%>") or
						string.find(fileName, "%|") then
						app:showMessage("Invalid file name.")
					else
						app:showMessage(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)
						if fs.exists(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName) then
							os.messageBox("message", "\"" .. fileName .. "\"Already exists. Delete?", "Warning", 
							{ 
								{caption = "Yes", 
									onClick = function(sender)
										fs.delete(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)

										local f = fs.open(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName, "w")
										f.write("\r\n")
										f.close()

										os.hideMessageBox()
									end
								},

								{caption = "No",
									onClick = function(sender)
										os.hideMessageBox()
									end
								} 

							}, "defText")
						else
							local f = fs.open(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName, "w")
							f.write("\r\n")
							f.close()
						end
					end

					listView:refreshList()
					desktop:refresh()
					os.hideMessageBox()
				end
			},

			{caption = "Cancel",
				onClick = function(sender)
					os.hideMessageBox()
				end
			} 

		}, "New File.txt")	
end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New folder", function(sender)
		os.messageBox("input", "New folder name:", "Create Folder...", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					local fileName = sender.parent.widgets.edit.text

					if string.find(fileName, "%/") or string.find(fileName, "%\\") or
						string.find(fileName, "%:") or string.find(fileName, "%*") or
						string.find(fileName, "%?") or string.find(fileName, "%\"") or
						string.find(fileName, "%<") or string.find(fileName, "%>") or
						string.find(fileName, "%|") then
						app:showMessage("Invalid folder name.")
					else
						app:showMessage(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)
						if fs.exists(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName) then
							os.messageBox("message", "\"" .. fileName .. "\"Already exists. Delete?", "Warning", 
							{ 
								{caption = "Yes", 
									onClick = function(sender)
										fs.delete(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)

										fs.makeDir(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)

										os.hideMessageBox()
									end
								},

								{caption = "No",
									onClick = function(sender)
										os.hideMessageBox()
									end
								} 

							}, "defText")
						else
							fs.makeDir(string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)
						end
					end

					listView:refreshList()
					desktop:refresh()
					os.hideMessageBox()
				end
			},

			{caption = "Cancel",
				onClick = function(sender)
					os.hideMessageBox()
				end
			} 

		}, "New Folder")	
end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Create shortcut", function(sender)
	if #(listView.selectedList) > 0 then
		os.shell.run("lnkcreate \"" .. listView.path .. "/" .. listView.list[listView.selectedList[1\]\].name .. "\" \"" ..
			listView.path .. "/" .. listView.list[listView.selectedList[1\]\].name .. ".lnk\"")
	end
end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", function(sender)  end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Refresh", function(sender) 
	listView:refreshList()
	desktop:refresh() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", function(sender)  end))

table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Open", 
	function(sender)
		if #(listView.selectedList) > 0 then
			os.shell.run("\"" .. listView.path .. "/" .. listView.list[listView.selectedList[1\]\].name .. "\"")
		end
	end))

table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Open with...",
	function(sender)
		if #(listView.selectedList) > 0 then
			local s = listView.list[listView.selectedList[1\]\].name
			local ext = "?"
			if (string.len(s) > 0) and (string.find(s, "%.") and s[0] ~= "." ) then
				local fn = user.split(s, ".")
				ext = fn[#fn]
			end

			os.shell.run("opendlg " .. ext .. " \"" ..
				listView.path .. "/" .. listView.list[listView.selectedList[1\]\].name .. "\"")
		end
	end))

table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Run in CraftOS Mode", 
	function(sender)
		if #(listView.selectedList) > 0 then
			os.shell.run("ncvm.app \"" .. listView.path .. "/" .. listView.list[listView.selectedList[1\]\].name .. "\"")
		end
	end))

table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", function(sender)  end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Exit", function(sender) app:terminate() end))


local editMenu = widgets.PopupMenu.Create()
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Cut", function(sender)
	local selList = listView.selectedList
	if #selList > 0 then
		local fileList = { action = "_MOVE", files = {} }

		for i, v in ipairs(listView.selectedList) do
			table.insert(fileList.files, listView.path .. "/" .. listView.list[v].name)
		end

		os.copyToClipboard(fileList, "_FILELIST")
	end
end))
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Copy", function(sender)
	local selList = listView.selectedList
	if #selList > 0 then
		local fileList = { action = "_COPY", files = {} }

		for i, v in ipairs(listView.selectedList) do
			table.insert(fileList.files, listView.path .. "/" .. listView.list[v].name)
		end

		os.copyToClipboard(fileList, "_FILELIST")
	end
end))
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Paste", function(sender)
	local fileList = os.pasteFromClipboard("_FILELIST")
	local conflictList = {}

	if (fileList ~= nil) and (fileList.files ~= nil) then
		--error("paste")

		for i, v in ipairs(fileList.files) do
			local from = string.gsub(v, "home:/", "", 1)
			local to = string.gsub(listView.path, "home:/", "", 1) .. "/" .. os.extractFileName(from)

			if fs.exists(to) then
				table.insert(conflictList, {from = from, to = to})
			else
				if fileList.action == "_COPY" then
					fs.copy(from, to)
				else
					fs.move(from, to)
				end
			end
		end

		if #conflictList > 0 then
			frmWarning.widgets.lstWarning.list = {}

			for i, v in ipairs(conflictList) do
				table.insert(frmWarning.widgets.lstWarning.list, "home:/" .. v.from)
			end

			frmWarning:show()
			os.sendMessage(hwnd, {msg = "refresh"})
		end

		-----------------------
		listView:refreshList()
		desktop:refresh()
	end
end))
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Rename", function(sender)
	local selList = listView.selectedList
	if #selList > 0 then
		os.messageBox("input", "New file name:", "Rename \"" .. listView.list[selList[1\]\].name .. "\"", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					local fileName = sender.parent.widgets.edit.text

					if string.find(fileName, "%/") or string.find(fileName, "%\\") or
						string.find(fileName, "%:") or string.find(fileName, "%*") or
						string.find(fileName, "%?") or string.find(fileName, "%\"") or
						string.find(fileName, "%<") or string.find(fileName, "%>") or
						string.find(fileName, "%|") then
						app:showMessage("Invalid file name.")
					else
						fs.move(string.gsub(listView.path, "home:/", "", 1) .. "/" .. listView.list[selList[1\]\].name,
							string.gsub(listView.path, "home:/", "", 1) .. "/" .. fileName)
					end

					listView:refreshList()
					desktop:refresh()
					os.hideMessageBox()
				end
			},

			{caption = "Cancel",
				onClick = function(sender)
					os.hideMessageBox()
				end
			} 

		}, listView.list[selList[1\]\].name)
	end
end))
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Delete", function(sender)
	local selList = listView.selectedList
	if #selList > 0 then
		os.messageBox("message", "Are you sure?", "Deleting Files", 
		{ 
			{caption = "Yes", 
				onClick = function(sender)
					for i, v in ipairs(listView.selectedList) do
						fs.delete(string.gsub(listView.path, "home:/", "", 1) .. "/" .. listView.list[v].name)
					end

					listView:refreshList()
					desktop:refresh()
					os.hideMessageBox()
				end
			},

			{caption = "No",
				onClick = function(sender)
					os.hideMessageBox()
				end
			} 

		}, "defText")
	end
end))

local helpMenu = widgets.PopupMenu.Create()
table.insert(helpMenu.items, widgets.PopupMenu.CreateItem("About", function(sender) os.shell.run("winver Explorer") end))



local searchBox = widgets.Edit.Create(desktop, "searchBox")
searchBox.top = 8
searchBox.left = 18
searchBox.width = 14
searchBox.height = 1
searchBox.visible = false
searchBox.text = ""


local searchList = widgets.ListBox.Create(desktop, "searchList")
searchList.top = listView.top
searchList.left = listView.left
searchList.width = listView.width
searchList.height = listView.height
searchList.visible = false
searchList.onMouseClick = function(sender, button, x, y)
	local time = os.time()

	if (time - lastSearchTime) * 10 < config.PROCESS_TIMER then
		if (#(searchList.list) > 0) and (x < sender.left + sender.width - 1) then
			local nav = string.gsub(searchList.list[searchList.index], "//", "/")
			if not fs.isDir(nav) then
				nav = os.extractFilePath(nav)
			end
			if not user.stringstarts(nav, "home:/") then
				nav = "home:/" .. nav
			end

			os.shell.run("explorer.app \"" .. nav .. "\"")
		end
	end

	lastSearchTime = time
end


local searchPanel = widgets.PaintBox.Create(desktop, "searchPanel")
searchPanel.top = listView.height - 10 + 5
searchPanel.left = 0
searchPanel.width = 14
searchPanel.height = 10
searchPanel.bgcolor = colors.blue
searchPanel:refresh()

local MikuSprites = {}
MikuSprites["idle"]    = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/idle.pic")
MikuSprites["s1"]      = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/s1.pic")
MikuSprites["s2"]      = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/s2.pic")
MikuSprites["happy1"]  = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/happy1.pic")
MikuSprites["happy2"]  = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/happy2.pic")
MikuSprites["up"]      = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/up.pic")
MikuSprites["down"]    = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/down.pic")
MikuBalloonPic         = user.loadCanvas(os.getSystemPath() .. "/assets/Miku/balloon.pic")

local MikuEnabled = false
local MikuJustEnabled = false
local MikuShowingBalloon = false
local MikuCurrent = "lifting"  -- "lifting", "idle", "searching", "happy", "comingdown"
local MikuCurrentText = ""
local MikuCurrentWord = 0
local MikuCurrentTextSplit = {}
local MikuPartStr = ""
local MikuCounter = 0
local MikuBeforeActionCounter = 0
local MikuSaying = 0
local MikuGoingToIdle = false
local MikuGoingToExit = false
local oldListViewLeft = 0


listView.onAfterRefresh = function(sender)
	if MikuShowingBalloon then
		if sender.canvas ~= nil then
			sender.canvas:draw(-1, 0, MikuBalloonPic, nil, true, colors.purple)
			sender.canvas:setCursorPos(4, 3)
			sender.canvas.forecolor = colors.black
			sender.canvas:write(MikuPartStr)

			if searchBox.visible then
				desktop.focusedWidget = searchBox
			end
		end
	end
end


searchPanel.mouseClick = function(sender)
	if (MikuCurrent == "idle") and (MikuSaying == 0) then
		MikuCurrent = "happy"
		MikuCounter = 0
		MikuBeforeActionCounter = 0
		MikuShowingBalloon = false
	end

	if (MikuCurrent == "idle") and (MikuSaying == 2) then
		searchBox.visible = false
		desktop.focusedWidget = nil
		MikuShowingBalloon = false
		MikuSaying = 3
		MikuBeforeActionCounter = 0
		MikuCurrent = "searching"

		listView.visible = false
		oldListViewLeft = listView.left

		searchList.top = listView.top
		searchList.left = listView.left
		searchList.width = listView.width
		searchList.height = listView.height

		listView.left = app.canvas.size.x + 2
		searchList.visible = true
		searchBox.visible = false
		desktop.focusedWidget = nil

		if not app:createThread(function()
			local function searchIn(path)
				local list = fs.list(path)
				for i, v in ipairs(list) do
					if string.find(v, searchBox.text) ~= nil then
						searchList:add(path .. "/" .. v)
					end
					coroutine.yield()
					if fs.isDir(path .. "/" .. v) then
						searchIn(path .. "/" .. v)
					end
				end
			end

			MikuSaying = 6
			searchIn("/")
			MikuSaying = 4
			MikuGoingToIdle = true
		end) then error("Unable to create search thread!") end
	end

	if (MikuCurrent == "idle") and (MikuSaying == 4) then
		MikuSaying = 5
		MikuGoingToIdle = false
		MikuGoingToExit = true
		MikuCounter = 0
		MikuCurrent = "happy"
		searchList:clear()
		MikuAnimate()
		searchPanel.visible = false
		MikuBeforeActionCounter = 0
		os.sendMessage(hwnd, {msg = "refresh"})
	end

	--\[\[if (MikuCurrent == "searching") and MikuSaying == 6 then
		MikuSaying = 5
		MikuGoingToIdle = true
		MikuGoingToExit = false
		MikuCounter = 0
		MikuCurrent = "happy"
		MikuBeforeActionCounter = 0
		app.threads = {}
	end\]\]
end


function MikuSay(text)
	if text ~= MikuCurrentText then
		MikuCurrentText = text
		MikuCurrentTextSplit = user.split(text, " ")
		MikuCurrentWord = 0
		MikuPartStr = ""
	end

	if MikuCurrentWord < #MikuCurrentTextSplit then
		MikuCurrentWord = MikuCurrentWord + 1
		MikuPartStr = MikuPartStr .. MikuCurrentTextSplit[MikuCurrentWord] .. " "
	end
end


function MikuAnimate()
	if MikuJustEnabled then
		MikuCurrent = "idle"
		MikuCounter = 0
		MikuEnabled = true
		MikuJustEnabled = false
		MikuSaying = 0
	end

	if MikuEnabled then
		if MikuCurrent == "idle" then
			MikuCounter = MikuCounter + 1

			if MikuSaying == 0 then
				if MikuCounter == 1 then
					searchPanel.canvas:clear()
					searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["idle"])
				elseif MikuCounter == 3 then
					MikuShowingBalloon = true
					MikuSay("")
				elseif (MikuCounter >= 5) and (MikuCounter < 12) then
					MikuSay("Hi! I'm Miku.")
				elseif (MikuCounter >= 12) and (MikuCounter < 16) then
					MikuSay("I am here to")
				elseif (MikuCounter >= 16) and (MikuCounter < 22) then
					MikuSay("find files.")
				elseif (MikuCounter >= 22) and (MikuCounter < 25) then
					MikuSay("Click me!")
				end
			end

			if MikuSaying == 1 then
				if MikuCounter == 1 then
					searchPanel.canvas:clear()
					searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["idle"])
				elseif MikuCounter == 3 then
					MikuShowingBalloon = true
					MikuSay("")
				elseif (MikuCounter >= 5) and (MikuCounter < 8) then
					MikuSay("Tell me what")
				elseif (MikuCounter >= 8) and (MikuCounter < 12) then
					MikuSay("should I")
				elseif (MikuCounter >= 12) and (MikuCounter < 17) then
					MikuSay("look for:")
				elseif MikuCounter == 17 then
					searchBox.visible = true
					desktop.focusedWidget = searchBox
					MikuSaying = 2
				end
			end

			if MikuSaying == 4 then
				if MikuCounter == 1 then
					searchPanel.canvas:clear()
					searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["idle"])
				elseif MikuCounter == 3 then
					MikuShowingBalloon = true
					MikuSay("")
				elseif (MikuCounter >= 5) and (MikuCounter < 8) then
					if #(searchList.list) > 0 then
						MikuSay("Look what I found!")
					else
						MikuSay("I found nothing!")
					end
				end
			end
		elseif MikuCurrent == "happy" then
			MikuCounter = MikuCounter + 1
			MikuBeforeActionCounter = MikuBeforeActionCounter + 1

			if MikuBeforeActionCounter == 12 then
				if not MikuGoingToExit then
					MikuBeforeActionCounter = 0
					MikuCounter = 0
					MikuSaying = MikuSaying + 1
					MikuCurrent = "idle"
				else
					MikuGoingToExit = false
					showSearch = false
					os.shell.run("explorer.app \"" .. listView.path .. "\"")
					app:terminate()
					RepositionEverything()
				end
			end

			if MikuCounter == 1 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["happy1"])
			elseif MikuCounter == 3 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["happy2"])
			elseif MikuCounter == 5 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["happy1"])
				MikuCounter = 0
			end
		elseif MikuCurrent == "searching" then
			MikuCounter = MikuCounter + 1

			if MikuCounter == 1 then
				searchPanel.canvas:clear()
			elseif MikuCounter == 2 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 4, MikuSprites["up"])
			elseif MikuCounter == 3 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 8, MikuSprites["up"])
			elseif MikuCounter == 4 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 9, MikuSprites["up"])
			elseif MikuCounter == 5 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["down"])
			elseif MikuCounter == 6 then
				if MikuGoingToIdle then
					MikuCurrent = "idle"
					MikuCounter = 0
					return nil
				end
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["s1"])
			elseif MikuCounter == 10 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["s2"])
			elseif MikuCounter == 14 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["s1"])
			elseif MikuCounter == 18 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["s2"])
			elseif MikuCounter == 22 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 10, MikuSprites["s1"])
			elseif MikuCounter == 23 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 9, MikuSprites["down"])
			elseif MikuCounter == 24 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 8, MikuSprites["down"])
			elseif MikuCounter == 25 then
				searchPanel.canvas:clear()
				searchPanel.canvas:draw(0, searchPanel.height - 4, MikuSprites["down"])
			elseif MikuCounter == 26 then
				searchPanel.canvas:clear()
			elseif MikuCounter >= 30 then
				MikuCounter = 0
			end
		end
	else
		MikuShowingBalloon = false

		if searchList.visible then
			listView.left = oldListViewLeft
			listView.visible = true
			searchList.visible = false
			desktop.focusedWidget = nil
		end

		if searchBox.visible then
			searchBox.visible = false
			desktop.focusedWidget = nil
		end
	end
end



searchPanel.canvas.effect = {
	getbgcolor = function(self, x, y, bgcolor, forecolor, char)
		if bgcolor == colors.white then
			return searchPanel.bgcolor
		end
		if bgcolor == colors.purple then
			return colors.white
		end
		return bgcolor
	end,
	getforecolor = function(self, x, y, bgcolor, forecolor, char)
		return forecolor
	end,
	getchar = function(self, x, y, bgcolor, forecolor, char)
		return char
	end,
}

searchPanel.canvas.bgcolor = colors.blue
--searchPanel.canvas:draw(0, 0, MikuSprites["idle"])



--\[\[local lblPlaces = widgets.Label.Create(desktop, "lblPlaces")
lblPlaces.top = 5
lblPlaces.left = 1
lblPlaces.width = 14
lblPlaces.height = 1
lblPlaces.bgcolor = colors.white
lblPlaces.caption = "Places:"
lblPlaces.visible = false\]\]

local popularPlaces = widgets.ListBox.Create(desktop, "popularPlaces")
popularPlaces.top = 5
popularPlaces.left = 0
popularPlaces.width = 14
popularPlaces.height = listView.height - searchPanel.height
popularPlaces.bgcolor = colors.white

places_titles = {}
table.insert(places_titles, "Home")
table.insert(places_titles, "Documents")
table.insert(places_titles, "Desktop")
table.insert(places_titles, "System")
table.insert(places_titles, "ROM")

places_locations = {
	Home = "home:/",
	Documents = "home:/$WIN$/userdata/Documents/",
	Desktop = "home:/$WIN$/userdata/Desktop/",
	System = "home:/$WIN$/",
	ROM = "home:/rom/",
}

for i, v in ipairs(places_titles) do
	popularPlaces:add(v)
end


sides = peripheral.getNames()
for i, v in ipairs(sides) do
	if peripheral.getType(v) == "drive" then
		places_locations[disk.getMountPath(v)] = "home:/" .. disk.getMountPath(v)
		table.insert(places_titles, disk.getMountPath(v))
		popularPlaces:add(disk.getMountPath(v))
	end
end


popularPlaces.onClick = function(sender)
	local time = os.time()

	if (time - lastPlacesTime) * 10 < config.PROCESS_TIMER then
		local nav = string.gsub(places_locations[sender.list[sender.index\]\], "%$WIN%$", os.getSystemPath())
		listView:navigate(nav)
		listView.selectedList = {}
	end

	lastPlacesTime = time
end



function RepositionEverything()
	if showPlaces or showSearch then
		listView.left = 14
		listView.width = app.canvas.size.x - 13
	else
		listView.left = 1
		listView.width = app.canvas.size.x
	end

	if showPlaces and showSearch then
		searchPanel.top = listView.height - 10 + 5
		searchPanel.height = 10
		searchPanel.visible = true
		popularPlaces.height = listView.height - searchPanel.height
		popularPlaces.visible = true
	else
		if showPlaces then
			searchPanel.visible = false
			popularPlaces.height = listView.height
			popularPlaces.visible = true
		elseif showSearch then
			popularPlaces.visible = false
			searchPanel.top = 5
			searchPanel.height = listView.height
			searchPanel.visible = true
		else
			popularPlaces.visible = false
			searchPanel.visible = false
		end
	end

	if searchPanel.visible and not MikuJustEnabled and not MikuEnabled then
		MikuJustEnabled = true
	end

	if not searchPanel.visible and MikuEnabled then
		MikuEnabled = false
	end

	os.sendMessage(hwnd, {msg = "refresh"})
end


local panelsMenu = widgets.PopupMenu.Create()
table.insert(panelsMenu.items, widgets.PopupMenu.CreateItem("[X] Popular Places",
	function(sender)
		if showPlaces then
			sender.text = "[ ] Popular Places"
		else
			sender.text = "[X] Popular Places"
		end
		showPlaces = not showPlaces
		RepositionEverything()
	end))

table.insert(panelsMenu.items, widgets.PopupMenu.CreateItem("[ ] Search",
	function(sender)
		if showSearch then
			sender.text = "[ ] Search"
		else
			sender.text = "[X] Search"
		end
		showSearch = not showSearch
		RepositionEverything()
	end))


local menu = widgets.MenuBar.Create(desktop, "Menu")
table.insert(menu.items, widgets.MenuBar.CreateItem("File", function(sender) widgets.popupMenu(fileMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Edit", function(sender) widgets.popupMenu(editMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Window", function(sender) widgets.popupMenu(panelsMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Help", function(sender) widgets.popupMenu(helpMenu, sender.left, sender.top + 2) end))

RepositionEverything()


if params[2] ~= nil then
	listView:navigate(params[2])
else
	listView:navigate("home:/")
end



local lastTimerTime = os.time()
local delta = 0.05

local function timerRefresh()
	if lastTimerTime > 0 then
		delta = 0.25 / ((os.time() - lastTimerTime) * 60 * 6 * 6)
		--error(tostring(delta))
		--app:showMessage(tostring(delta), "")
	end

	os.startTimer(delta, timerRefresh)
	MikuAnimate()
	if MikuEnabled then
		os.sendMessage(hwnd, {msg = "refresh"})
	end
	lastTimerTime = os.time()
end

os.startTimer(0.05, timerRefresh)

app:run()]])
table.insert(names, "/system2/folder.pic")
table.insert(values, [[pic|3|4|41 14 14 14 41 14 14 14 41 14 14 14 ]])
table.insert(names, "/system2/ini.pic")
table.insert(values, [[pic|3|4|b3 b3 b3 b3 0b=0b=0b=0b=0b=0bi0bn0bi]])
table.insert(names, "/system2/lnkcreate.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Create Shortcut")

app:addForm(mainForm, "Create Shortcut")
mainForm:show()


local saveDialog = widgets.dialogs.SaveDialog.Create(mainForm, "SaveDialog")
local openDialog = widgets.dialogs.OpenDialog.Create(mainForm, "OpenDialog")
local ico = false

saveDialog.onExecute = function(sender)
	sender.parent.widgets.shName.text = sender.fileName or ""
	os.sendMessage(hwnd, {msg = "refresh"})
end

openDialog.onExecute = function(sender)
	if ico then
		sender.parent.widgets.icoName.text = sender.fileName or ""
	else
		sender.parent.widgets.fileName.text = sender.fileName or ""
	end

	os.sendMessage(hwnd, {msg = "refresh"})
end




local lbl1 = widgets.Label.Create(mainForm, "lbl1")
lbl1.left = 2
lbl1.top = 2
lbl1.caption = "File destination:"
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1

local fileName = widgets.Edit.Create(mainForm, "fileName")
fileName.left = 2
fileName.top = 4
fileName.width = app.canvas.size.x - 2 - 2 - 1
fileName.text = params[2] or ""

local btnBrowse1 = widgets.Button.Create(mainForm, "btnBrowse1")
btnBrowse1.width = 2
btnBrowse1.left = app.canvas.size.x - btnBrowse1.width
btnBrowse1.top = 4
btnBrowse1.forecolor2 = btnBrowse1.forecolor
btnBrowse1.caption = ".."
btnBrowse1.onClick = function(sender)
	ico = false
	openDialog:execute()
end



local lbl2 = widgets.Label.Create(mainForm, "lbl2")
lbl2.left = 2
lbl2.top = 6
lbl2.caption = "Shortcut destination:"
lbl2.width = app.canvas.size.x - 2
lbl2.height = 1

local shName = widgets.Edit.Create(mainForm, "shName")
shName.left = 2
shName.top = 8
shName.width = app.canvas.size.x - 5
shName.text = params[3] or ""

local btnBrowse2 = widgets.Button.Create(mainForm, "btnBrowse2")
btnBrowse2.width = 2
btnBrowse2.left = app.canvas.size.x - btnBrowse2.width
btnBrowse2.top = 8
btnBrowse2.forecolor2 = btnBrowse2.forecolor
btnBrowse2.caption = ".."
btnBrowse2.onClick = function(sender)
	saveDialog:execute()
end


local lbl3 = widgets.Label.Create(mainForm, "lbl3")
lbl3.left = 2
lbl3.top = 10
lbl3.caption = "Icon:"
lbl3.width = app.canvas.size.x - 2
lbl3.height = 1

local icoName = widgets.Edit.Create(mainForm, "icoName")
icoName.left = 2
icoName.top = 12
icoName.width = app.canvas.size.x - 5
icoName.text = params[4] or ""

local btnBrowse3 = widgets.Button.Create(mainForm, "btnBrowse3")
btnBrowse3.width = 2
btnBrowse3.left = app.canvas.size.x - btnBrowse3.width
btnBrowse3.top = 12
btnBrowse3.forecolor2 = btnBrowse3.forecolor
btnBrowse3.caption = ".."
btnBrowse3.onClick = function(sender)
	ico = true
	openDialog:execute()
end



local btnCmd = widgets.Button.Create(mainForm, "btnCmd")
btnCmd.width = 9
btnCmd.left = app.canvas.size.x - btnCmd.width
btnCmd.top = app.canvas.size.y - 2
btnCmd.caption = "Create"

btnCmd.onClick = function(sender)
	if (fileName.text == nil) or (fileName.text == "") or
	   (shName.text == nil) or (shName.text == "") or
	   (icoName.text == nil) or (icoName.text == "") then
		os.messageBox("message", "Please specify any command.", "Error", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
		}, "defText")
	else
		local lnk = {
			shortcut = {
				file = fileName.text,
				icon = icoName.text,
			}
		}

		if not user.stringends(shName.text, ".lnk") then shName.text = shName.text .. ".lnk" end
		if user.stringstarts(shName.text, "home:/") then shName.text = string.gsub(shName.text, "home:/", "", 1) end

		iniFiles.write(shName.text, lnk)
		app:terminate()
	end
end



--os.sendMessage(hwnd, {msg = "refresh"})

app:run()]])
table.insert(names, "/system2/lnkview.app")
table.insert(values, [[if params[2] ~= nil then
	local lnkdata = iniFiles.read(params[2])

	if lnkdata ~= nil then
		os.shell.run(lnkdata.shortcut.file)
	end
end]])
table.insert(names, "/system2/lua.pic")
table.insert(values, [[pic|3|4|cc cc cc cc 0c=0c=0c=0c=0c=0cl0cu0ca]])
table.insert(names, "/system2/luaedit.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("LUA Editor")
local currentFileName = ""
local commandArgs = ""


app:addForm(mainForm, "LUA Editor")
mainForm:show()
mainForm.bgcolor = colors.black


local textArea = widgets.TextArea.Create(mainForm, "textArea", widgets)
textArea.left = 1
textArea.top = 2
textArea.height = app.canvas.size.y - 2
textArea.width = app.canvas.size.x
textArea.text = ""
textArea.bgcolor = colors.black
textArea.forecolor = colors.white



function SyntaxHighlighter_Create()
	local charList = {}
	charList["+"] = true
	charList["-"] = true
	charList["*"] = true
	charList["/"] = true
	charList["="] = true
	charList["~"] = true
	charList[">"] = true
	charList["<"] = true


	local keyList = {}
	keyList["function"] = false
	keyList["if"] = false
	keyList["then"] = false
	keyList["return"] = false
	keyList["end"] = false
	keyList["elseif"] = false
	keyList["else"] = false
	keyList["local"] = false
	keyList["_G"] = false
	keyList["for"] = false
	keyList["in"] = false
	keyList["do"] = false
	keyList["repeat"] = false
	keyList["until"] = false
	keyList["while"] = false
	keyList[".."] = false
	keyList["and"] = false
	keyList["or"] = false
	keyList["not"] = false


	stringConstChars = {}
	stringConstChars["\""] = true
	stringConstChars["\'"] = true


	local numChars = {}
	numChars["0"] = true
	numChars["1"] = true
	numChars["2"] = true
	numChars["3"] = true
	numChars["4"] = true
	numChars["5"] = true
	numChars["6"] = true
	numChars["7"] = true
	numChars["8"] = true
	numChars["9"] = true



	local otherChars = {}
	otherChars["."] = true
	otherChars[":"] = true
	otherChars["("] = true
	otherChars[")"] = true
	otherChars["{"] = true
	otherChars["}"] = true
	otherChars["["] = true
	otherChars["]"] = true
	otherChars["\\"] = true	


	local highlighter = {
		specialChars = {
			list = charList,
			bgcolor = colors.black,
			forecolor = colors.red,			
		},

		keyWords = {
			list = keyList,
			bgcolor = colors.black,
			forecolor = colors.red,
		},

		stringConsts = {
			list = stringConstChars,
			bgcolor = colors.black,
			forecolor = colors.yellow,
		},

		comments = {
			bgcolor = colors.black,
			forecolor = colors.gray,
		},

		numbers = {
			list = numChars,
			bgcolor = colors.black,
			forecolor = colors.purple,
		},

		others = {
			list = otherChars,
			bgcolor = colors.black,
			forecolor = colors.lightGray,
		},

		commentOpened = false,
		bracketOpened = false,
		bogCommentOpened = false,
		bigBracketOpened = false,
		echoed = false,
		highlightCanvas = nil,

		scrolling = {
			left = 0,
			top = 0,
		},



		getWordColor = function(self, word)
			if self.keyWords.list[word] ~= nil then
				return self.keyWords.forecolor
			else
				return nil
			end
		end,


		getStringConstColor = function(self, word)
			if user.stringstarts(word, "\[\[") then
				self.bigBracketOpened = true
			end

			if user.stringends(word, "\]\]") then
				self.bigBracketOpened = false
			end


			if self.bigBracketOpened then
				return self.stringConsts.forecolor
			end
		end,


		getCommentColor = function(self, word)
			if (not self.commentOpened) or (not self.bigCommentOpened) then
				if user.stringstarts(word, "--") then
					self.commentOpened = true
				end
			end

			if self.commentOpened or self.bigCommentOpened then
				return self.comments.forecolor
			end
		end,


		countSpaces = function(self, str)
			local index = 1

			if string.sub(str, index, index) == " " then
				repeat
					index = index + 1
				until not (string.sub(str, index, index) == " ")
			end

			return index
		end,



		parseAreaData = function(self, areaData, forecolor, sizeX, sizeY)
			self.highlightCanvas = user.CreateCanvas(256, #areaData)
			self.bigBracketOpened = false



			for i = self.scrolling.top, self.scrolling.top + sizeY do
				local v = areaData[i] or ""
				local line = string.gsub(string.gsub(string.gsub(v, "\t", " "), "\r", ""), "\0", "")
				local left = self:countSpaces(line)
				line = string.sub(line, left)
				local words = user.split(line, " ")
				--self.bracketOpened = false
				self.commentOpened = false


				for j, word in ipairs(words) do
					self.highlightCanvas.bgcolor = self:getCommentColor(word) or self:getStringConstColor(word) or self:getWordColor(word) or forecolor
					self.highlightCanvas:setCursorPos(left, i)
					self.highlightCanvas:write(word)

					left = left + string.len(word) + 1
				end
			end
		end,


		setScrolling = function(self, scrolling)
			self.scrolling = scrolling
		end,


		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			if (self.bracketOpened) or (self.stringConsts.list[char] ~= nil)  then
				return self.stringConsts.bgcolor
			else
				if self.specialChars.list[char] ~= nil then
					return self.specialChars.bgcolor
				else
					return bgcolor
				end
			end
		end,


		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			local x = x + self.scrolling.left - 1
			local y = y + self.scrolling.top

			if (self.highlightCanvas ~= nil) and (self.highlightCanvas.data[y] ~= nil) and (self.highlightCanvas.data[y][x] ~= nil) then
				if self.highlightCanvas.data[y][x].bgcolor ~= forecolor then
					return self.highlightCanvas.data[y][x].bgcolor
				else
					if ((self.bracketOpened) or (self.stringConsts.list[char] ~= nil)) then
						return self.stringConsts.forecolor
					end
				end
			end

			if self.specialChars.list[char] ~= nil then
				return self.specialChars.forecolor
			elseif self.numbers.list[char] ~= nil then
				return self.numbers.forecolor
			elseif self.others.list[char] ~= nil then
				return self.others.forecolor
			else
				return forecolor
			end
		end,


		getchar = function(self, x, y, bgcolor, forecolor, char)
			if x == 1 then self.bracketOpened = false end

			if char == "\\" then
				self.echoed = true
			end


			if (self.stringConsts.list[char] ~= nil) and (not (self.echoed)) then
				if self.bracketOpened then self.bracketOpened = false else self.bracketOpened = true end
			end

			self.echoed = false
			return char
		end,
	}

	return highlighter
end




textArea.syntaxHighlighter = SyntaxHighlighter_Create()




function loadFile(fileName)
	local file = fs.open(fileName, "r")
	local text = ""

	if file ~= nil then
		text = file.readAll()
		file.close()
	end

	currentFileName = fileName
	mainForm.name = "[" .. fileName .. "] - LUA Editor"
	os.sendMessage(hwnd, {msg = "refresh"})

	textArea:setText(text)
	textArea:refresh()
end


function saveFile(fileName)
	local file = fs.open(fileName, "w")
	local text = textArea:getText()

	if file ~= nil then
		file.write(text)
		file.close()
	end

	currentFileName = fileName
	mainForm.name = "[" .. fileName .. "] - LUA Editor"
end


function loadArgs()
	local settings = iniFiles.read(os.getSystemPath() .. "/system2/luaedit.ini") or {}
	local debug = settings.debug or { args = "" }

	commandArgs = debug.args

	settings.debug = debug
	iniFiles.write(os.getSystemPath() .. "/system2/luaedit.ini", settings)
end


function saveArgs()
	local settings = iniFiles.read(os.getSystemPath() .. "/system2/luaedit.ini") or {}
	local debug = settings.debug or { args = commandArgs }

	settings.debug = debug
	iniFiles.write(os.getSystemPath() .. "/system2/luaedit.ini", settings)
end






local saveDialog = widgets.dialogs.SaveDialog.Create(mainForm, "SaveDialog")

saveDialog.onExecute = function(sender)
	local fileName = string.gsub(sender.fileName, "home:/", "", 1)
	saveFile(fileName)
end



local openDialog = widgets.dialogs.OpenDialog.Create(mainForm, "OpenDialog")

openDialog.onExecute = function(sender)
	local fileName = string.gsub(sender.fileName, "home:/", "", 1)
	loadFile(fileName)
end



function file_newClick()
	os.shell.run("notepad")
	app:terminate()
end

function file_openClick()
	openDialog:execute()
end

function file_saveClick()
	if currentFileName ~= "" then
		saveFile(currentFileName)
	else
		saveDialog:execute()
	end
end

function file_saveAsClick()
	saveDialog:execute()
end

function file_exitClick()
	app:terminate()
end




local fileMenu = widgets.PopupMenu.Create()
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New", function(sender) file_newClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Open", function(sender) file_openClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save", function(sender) file_saveClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save As..", function(sender) file_saveAsClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Exit", function(sender) file_exitClick() end))


local runMenu = widgets.PopupMenu.Create()
table.insert(runMenu.items, widgets.PopupMenu.CreateItem("Run", function(sender)
	if currentFileName ~= "" then
		saveFile(currentFileName)
	else
		saveDialog:execute()
	end

	os.shell.run(currentFileName .. " " .. commandArgs)
end))

table.insert(runMenu.items, widgets.PopupMenu.CreateItem("-", nil))

table.insert(runMenu.items, widgets.PopupMenu.CreateItem("Command line arguments", function(sender)
	os.messageBox("input", "Command line argunemts:", "Run", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					commandArgs = sender.parent.widgets.edit.text
					saveArgs()
					os.hideMessageBox()
				end
			},

			{caption = "Cancel", 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
		}, commandArgs)
end))



local helpMenu = widgets.PopupMenu.Create()
table.insert(helpMenu.items, widgets.PopupMenu.CreateItem("About", function(sender) os.shell.run("winver \"LUA Editor\"") end))


local menu = widgets.MenuBar.Create(mainForm, "Menu")
table.insert(menu.items, widgets.MenuBar.CreateItem("File", function(sender) widgets.popupMenu(fileMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Run", function(sender) widgets.popupMenu(runMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Help", function(sender) widgets.popupMenu(helpMenu, sender.left, sender.top + 2) end))








if params[2] ~= nil then
	loadFile(string.gsub(params[2], "home:/", "", 1))
end

loadArgs()



os.startTimer(5, function()
	textArea:refresh(true)
	os.sendMessage(hwnd, {msg = "refresh"})
end )
app:run()]])
table.insert(names, "/system2/luaedit.ini")
table.insert(values, [[[debug]
args = ]])
table.insert(names, "/system2/ncvm.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Command Prompt")

app:addForm(mainForm, "Command Prompt")
mainForm:show()
mainForm.bgcolor = colors.black


local surface = widgets.GLSurface.Create(mainForm, "surface")
surface.height = app.canvas.size.y - 2
surface.width = app.canvas.size.x
surface.top = 2


--local cmd = string.gsub(params[0] or "home:/rom/programs/shell", "home:/", "")
local cmd = string.gsub(os.getSystemPath() .. "/sysWoW/rombios", "home:/", "")
local program = loadfile(cmd)
setfenv(program, legacyEnv)
local thread = coroutine.create(program)
local ended = false
local lastVisible = false
local running = true
local args = {}--{"/rom/startup"}
local messages = {}
local SHELL_INIT_FLAG = false


surface.onMouseClick = function(sender, button, x, y)
	table.insert(messages, {message = "mouse_click", button = button, x = x, y = y - 1})
end

surface.onMouseDrag = function(sender, button, x, y)
	table.insert(messages, {message = "mouse_drag", button = button, x = x, y = y - 1})
end

mainForm.onKeyPress = function(sender, key, char)
	table.insert(messages, {message = "key", key = key})

	if char ~= "" then
		table.insert(messages, {message = "char", char = char})
	end
end

mainForm.onMessage = function(sender, message)
	if (message[1] ~= "key") and (message[1] ~= "char") and
		(message[1] ~= "mouse_click") and (message[1] ~= "mouse_drag") then
		table.insert(messages, message)
	end
end


legacyEnv.term.clear()
legacyEnv.term.setCursorPos(1, 1)
legacyEnv.term.setCursorBlink(true)



legacyEnv.os.getSystemPath = os.getSystemPath
legacyEnv._WHAT_TO_RUN = string.gsub(params[2] or "", "home:/", "/")
if string.len(legacyEnv._WHAT_TO_RUN) == 0 then
	legacyEnv._WHAT_TO_RUN = nil
end


legacyEnv.os.pullEventRaw = function(target)
	local msg = nil

	while msg == nil do
		msg = table.remove(messages)

		if msg ~= nil then
			if (target ~= nil and msg.message == target) or target == nil then
				if msg.message == "key" then
					return "key", msg.key
				elseif msg.message == "char" then
					return "char", msg.char
				elseif msg.message == "mouse_click" then
					return "mouse_click", msg.button, msg.x, msg.y
				elseif msg.message == "mouse_drag" then
					return "mouse_drag", msg.button, msg.x, msg.y
				else
					return unpack(msg)
				end
			else
				msg = nil
			end
		else
			coroutine.yield()
		end
	end
end


legacyEnv.os.pullEvent = function(target)
	return legacyEnv.os.pullEventRaw(target)
end


legacyEnv.os.run = function(env, path, args)
	print(path)
end


setfenv(legacyEnv.read, legacyEnv)

legacyEnv.term.current = function()
	return legacyEnv.term
end

legacyEnv.term.redirect = function(obj)
end

legacyEnv.shell = nil



legacyEnv.http.request = function(url, postData, headers, handler)
	local function onSuccess(url, handle)
		if not handler then
			table.insert(messages, {"http_success", url, handle})
		else
			handler(true, url, handle)
		end
	end

	local function onFailure(url)
		if not handler then
			table.insert(messages, {"http_failure", url})
		else
			handler(false, url)
		end
	end


	local http = os.findWindowByTitle("http service")
	if http ~= nil then
		os.sendMessage(http, {
			msg = "request", 
			url = url,
			postData = postData,
			headers = headers,
			onSuccess = onSuccess,
			onFail = onFailure
		})
	else
		app:showMessage("Http service not found.\nPlease, reboot your computer.")
	end
end


legacyEnv.http.post = function(url, postData, headers)
	local result = nil
	local waiting = true
	local function handler(res, url, handle)
		result = handle
		waiting = false
	end

	legacyEnv.http.request(url, postData, headers, handler)
	while waiting do
		coroutine.yield()
	end

	return result
end


legacyEnv.http.get = function(url, headers)
	return legacyEnv.http.post(url, nil, headers)
end



mainForm.onRefresh = function(sender)
	os.redirectTerm(legacyEnv.term)
	if (coroutine.status(thread) == "suspended") and running then
		local status, message = pcall(function() assert(coroutine.resume(thread, unpack(args))) end)

		if (not status) and (not ended) then
			legacyEnv.term.setTextColor(colors.red)
			legacyEnv.term.setBackgroundColor(colors.black)
			legacyEnv.term.write(message)
			ended = true
		end
	end
	os.restoreTerm()

	--\[\[if cmd == "rom/programs/shell" and not SHELL_INIT_FLAG then
		--legacyEnv.os.run({}, "rom/startup")
		legacyEnv.term.write(tostring(legacyEnv.shell))
		SHELL_INIT_FLAG = true
	end\]\]

	local visible = os.getActiveProcess() == hwnd
	if visible ~= lastVisible then
		legacyEnv.term.setVisible(visible)
		lastVisible = visible
	end
	legacyEnv.term.redraw()
	legacyEnv.term.restoreCursor()
end


os.startTimer(0.1, function() --\[\[os.sendMessage(hwnd, {msg = "refresh"})\]\] mainForm:onRefresh() end )
app:run()]])
table.insert(names, "/system2/notepad.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Notepad")
local currentFileName = ""


app:addForm(mainForm, "Notepad")
mainForm:show()


local textArea = widgets.TextArea.Create(mainForm, "textArea", widgets)
textArea.left = 1
textArea.top = 2
textArea.height = app.canvas.size.y - 2
textArea.width = app.canvas.size.x
textArea.text = ""




function loadFile(fileName)
	local file = fs.open(fileName, "r")
	local text = ""

	if file ~= nil then
		text = file.readAll()
		file.close()
	end

	currentFileName = fileName
	mainForm.name = "[" .. fileName .. "] - Notepad"
	os.sendMessage(hwnd, {msg = "refresh"})

	textArea:setText(text)
	textArea:refresh()
end


function saveFile(fileName)
	local file = fs.open(fileName, "w")
	local text = textArea:getText()

	if file ~= nil then
		file.write(text)
		file.close()
	end

	currentFileName = fileName
	mainForm.name = "[" .. fileName .. "] - Notepad"
end






local saveDialog = widgets.dialogs.SaveDialog.Create(mainForm, "SaveDialog")

saveDialog.onExecute = function(sender)
	local fileName = string.gsub(sender.fileName, "home:/", "", 1)
	saveFile(fileName)
end



local openDialog = widgets.dialogs.OpenDialog.Create(mainForm, "OpenDialog")

openDialog.onExecute = function(sender)
	local fileName = string.gsub(sender.fileName, "home:/", "", 1)
	loadFile(fileName)
end



function file_newClick()
	os.shell.run("notepad")
	app:terminate()
end

function file_openClick()
	openDialog:execute()
end

function file_saveClick()
	if currentFileName ~= "" then
		saveFile(currentFileName)
	else
		saveDialog:execute()
	end
end

function file_saveAsClick()
	saveDialog:execute()
end

function file_exitClick()
	app:terminate()
end




local fileMenu = widgets.PopupMenu.Create()
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New", function(sender) file_newClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Open", function(sender) file_openClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save", function(sender) file_saveClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save As..", function(sender) file_saveAsClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Exit", function(sender) file_exitClick() end))

local helpMenu = widgets.PopupMenu.Create()
table.insert(helpMenu.items, widgets.PopupMenu.CreateItem("About", function(sender) os.shell.run("winver Notepad") end))


local menu = widgets.MenuBar.Create(mainForm, "Menu")
table.insert(menu.items, widgets.MenuBar.CreateItem("File", function(sender) widgets.popupMenu(fileMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Help", function(sender) widgets.popupMenu(helpMenu, sender.left, sender.top + 2) end))




if params[2] ~= nil then
	loadFile(string.gsub(params[2], "home:/", "", 1))
end




app:run()]])
table.insert(names, "/system2/opendlg.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Open With...")
app:addForm(mainForm, "Open With...")
mainForm:show()


local args = params
local customName = ""
local customPath = ""

function firstToUpper(str)
    return (str:gsub("^%l", string.upper))
end


function listInstalledSoftware()
	keys = os.getRegistryBranchKeys("installed")
	list = {}
	for i, v in ipairs(keys) do
		list[v] = os.getRegistryKeyValue("installed", v, "")
	end
	return list
end



local openDialog = widgets.dialogs.OpenDialog.Create(mainForm, "OpenDialog")
openDialog.onExecute = function(sender)
	if sender.fileName ~= nil then
		customName = firstToUpper(string.gsub(os.extractFileName(sender.fileName), "%.app", ""))
		customPath = "\"" .. sender.fileName .. "\" \"%FILENAME%\"" 
		sender.parent.widgets.appList:add(customName)
	end

	os.sendMessage(hwnd, {msg = "refresh"})
end



local lbl1 = widgets.Label.Create(mainForm, "lbl1")
lbl1.left = 2
lbl1.top = 2
lbl1.caption = "Choose program you want to use:"
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1


local appList = widgets.ListBox.Create(mainForm, "appList")
appList.top = 4
appList.height = app.canvas.size.y - 7
appList.width = app.canvas.size.x + 1
appList.left = 0

local installed = listInstalledSoftware()
for k, v in pairs(installed) do
	appList:add(k)
end


local chbRemember = widgets.CheckBox.Create(mainForm, "chbRemember")
chbRemember.width = 25
chbRemember.left = 2
chbRemember.top = app.canvas.size.y - 2
chbRemember.checked = true
chbRemember.caption = "Remember my choice"
if args[2] == "?" then
	chbRemember.checked = false
	chbRemember.grayed = true
end


local btnOpen = widgets.Button.Create(mainForm, "btnOpen")
btnOpen.width = 9
btnOpen.left = app.canvas.size.x - btnOpen.width
btnOpen.top = app.canvas.size.y - 2
btnOpen.caption = "Open"
btnOpen.onClick = function(sender)
	if chbRemember.checked then
		os.setRegistryKeyValue("extensions", args[2], installed[appList.list[appList.index\]\])
	end
	--error(tostring(args[3]))
	os.shell.run(string.gsub(installed[appList.list[appList.index\]\], "%%FILENAME%%", tostring(args[3])))
	app:terminate()
end


local btnBrowse = widgets.Button.Create(mainForm, "btnBrowse")
btnBrowse.width = 9
btnBrowse.left = app.canvas.size.x - btnOpen.width - btnBrowse.width - 1
btnBrowse.top = app.canvas.size.y - 2
btnBrowse.caption = "Browse"
btnBrowse.onClick = function(sender)
	openDialog:execute()
end


app:run()]])
table.insert(names, "/system2/paintbrush.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Paintbrush")
local bgcolor = colors.black
local forecolor = colors.white
local char = " "

local fileName = ""
local saved = true



app:addForm(mainForm, "Paintbrush")
mainForm:show()
mainForm.bgcolor = colors.gray


mainForm.onRefresh = function(sender)
	if fileName ~= "" then
		--error(fileName)
		if saved then
			mainForm.name = "[" .. os.extractFileName(fileName) .. "] - Paintbrush"
		else
			mainForm.name = "[" .. os.extractFileName(fileName) .. "]* - Paintbrush"
		end
	else
		mainForm.name = "Paintbrush"
	end
end



function openFile()
	if not saved then
		os.messageBox("message", "Save changes in current file?", "Save Changes", 
		{ 
			{caption = "Yes", 
				onClick = function(sender)
					saveFile(fileName)
					os.hideMessageBox()
					saved = true
					mainForm.widgets.OpenDialog:execute()
				end
			},

			{caption = "No",
				onClick = function(sender)
					os.hideMessageBox()
					mainForm.widgets.OpenDialog:execute()
				end
			} 

		}, "defText")
	else
		mainForm.widgets.OpenDialog:execute()
	end
end


function saveFile()
	if fileName == "" then
		mainForm.widgets.SaveDialog:execute()
		fileName = mainForm.widgets.SaveDialog.fileName
	else
		mainForm.widgets.SaveDialog.fileName = fileName
		mainForm.widgets.SaveDialog:onExecute()
	end
end


local paintBox = widgets.PaintBox.Create(mainForm, "PaintBox")
paintBox.top = 3
paintBox.left = 1
paintBox.height = 3
paintBox.width = 5



--app:showMessage(params[2])
if params[2] ~= nil then
	--mainForm.name = "[" .. params[2] .. "] - Paintbrush"
	--error(params[2])
	local canvas = user.loadCanvas(params[2])
	if canvas ~= nil then
		paintBox.height = canvas.size.y
		paintBox.width = canvas.size.x
		paintBox.pheight = canvas.size.y
		paintBox.pwidth = canvas.size.x
		paintBox.canvas = canvas
		fileName = params[2]
	end
	saved = true
end



local saveDialog = widgets.dialogs.SaveDialog.Create(mainForm, "SaveDialog")
local openDialog = widgets.dialogs.OpenDialog.Create(mainForm, "OpenDialog")
--saveDialog:execute()


local statusBar = widgets.Label.Create(mainForm, "StatusBar")
statusBar.top = app.canvas.size.y - 1
statusBar.left = 1
statusBar.width = app.canvas.size.x
statusBar.caption = " "





--\[\[local resizer = widgets.Label.Create(mainForm, "resizer")
resizer.top = paintBox.top + paintBox.height
resizer.left = paintBox.left + paintBox.width
resizer.height = 1
resizer.width = 1
resizer.caption = "*"
resizer.bgcolor = colors.gray
resizer.forecolor = colors.lightBlue\]\]

--mainForm.onMouseDrag = function(sender, button, x, y)
--	resizer.left = x
--	resizer.top = y
--end



saveDialog.onExecute = function(sender)
	user.saveCanvas(paintBox.canvas, sender.fileName)
	saved = true
	fileName = sender.fileName
end

openDialog.onExecute = function(sender)
	local canvas = user.loadCanvas(sender.fileName)
	if canvas ~= nil then
		paintBox.height = canvas.size.y
		paintBox.width = canvas.size.x
		paintBox.canvas = canvas
	end
	saved = true
	fileName = sender.fileName
end





local palette = widgets.Panel.Create(mainForm, "Palette")
palette.left = app.canvas.size.x - 6
palette.width = 6
palette.top = 2
palette.height = app.canvas.size.y - 2
palette.bgcolor = colors.lightGray


function onPaletteItemClick(sender)
	bgcolor = sender.bgcolor
end

function onPaletteItemPopup(sender)
	forecolor = sender.bgcolor
end


palette.widgets.bgcolor = widgets.Label.Create(palette, "bgcolor")
palette.widgets.bgcolor.top = 10
palette.widgets.bgcolor.left = 2
palette.widgets.bgcolor.height = 2
palette.widgets.bgcolor.width = 3
palette.widgets.bgcolor.caption = " "

palette.widgets.bgcolor.onRefresh = function(sender)
	sender.bgcolor = bgcolor
end


palette.widgets.forecolor = widgets.Label.Create(palette, "forecolor")
palette.widgets.forecolor.top = 12
palette.widgets.forecolor.left = 3
palette.widgets.forecolor.height = 1
palette.widgets.forecolor.width = 3
palette.widgets.forecolor.caption = " "

palette.widgets.forecolor.onRefresh = function(sender)
	sender.bgcolor = forecolor
end


palette.widgets.char = widgets.Edit.Create(palette, "char")
palette.widgets.char.top = 14
palette.widgets.char.left = 2
palette.widgets.char.height = 1
palette.widgets.char.width = 4
palette.widgets.char.text = " "

palette.widgets.char.onRefresh = function(sender)
	--if string.len(sender.text) > 0 then
	--	char = sender.text--string.sub(sender.text, 1, 2)
	--end
end


paintBox.onMouseClick = function(sender, button, x, y)
	--if string.len(palette.widgets.char.text) > 0 then
		char = palette.widgets.char.text--string.sub(sender.text, 1, 2)
	--end

	sender.canvas.bgcolor = bgcolor
	sender.canvas.forecolor = forecolor
	sender.canvas:point(x - sender.left, y - sender.top, char)
	statusBar.caption = "[x = " .. x - sender.left .. ", y = " .. y - sender.top .. ", char = " .. char .. "]"
	saved = false
end

paintBox.onMouseDrag = paintBox.onMouseClick




palette.widgets.forecolor2 = widgets.Label.Create(palette, "forecolor2")
palette.widgets.forecolor2.top = 11
palette.widgets.forecolor2.left = 5
palette.widgets.forecolor2.height = 2
palette.widgets.forecolor2.width = 1
palette.widgets.forecolor2.caption = " "
palette.widgets.forecolor2.onRefresh = palette.widgets.forecolor.onRefresh



palette.widgets["orange"] = widgets.Label.Create(palette, "orange")
palette.widgets["orange"].bgcolor = colors.orange
palette.widgets["orange"].caption = " "
palette.widgets["orange"].left = 2
palette.widgets["orange"].width = 2
palette.widgets["orange"].top = 1
palette.widgets["orange"].onClick = onPaletteItemClick
palette.widgets["orange"].onPopup = onPaletteItemPopup


palette.widgets["magenta"] = widgets.Label.Create(palette, "magenta")
palette.widgets["magenta"].bgcolor = colors.magenta
palette.widgets["magenta"].caption = " "
palette.widgets["magenta"].left = 4
palette.widgets["magenta"].width = 2
palette.widgets["magenta"].top = 1
palette.widgets["magenta"].onClick = onPaletteItemClick
palette.widgets["magenta"].onPopup = onPaletteItemPopup


palette.widgets["lightBlue"] = widgets.Label.Create(palette, "lightBlue")
palette.widgets["lightBlue"].bgcolor = colors.lightBlue
palette.widgets["lightBlue"].caption = " "
palette.widgets["lightBlue"].left = 2
palette.widgets["lightBlue"].width = 2
palette.widgets["lightBlue"].top = 2
palette.widgets["lightBlue"].onClick = onPaletteItemClick
palette.widgets["lightBlue"].onPopup = onPaletteItemPopup


palette.widgets["yellow"] = widgets.Label.Create(palette, "yellow")
palette.widgets["yellow"].bgcolor = colors.yellow
palette.widgets["yellow"].caption = " "
palette.widgets["yellow"].left = 4
palette.widgets["yellow"].width = 2
palette.widgets["yellow"].top = 2
palette.widgets["yellow"].onClick = onPaletteItemClick
palette.widgets["yellow"].onPopup = onPaletteItemPopup


palette.widgets["lime"] = widgets.Label.Create(palette, "lime")
palette.widgets["lime"].bgcolor = colors.lime
palette.widgets["lime"].caption = " "
palette.widgets["lime"].left = 2
palette.widgets["lime"].width = 2
palette.widgets["lime"].top = 3
palette.widgets["lime"].onClick = onPaletteItemClick
palette.widgets["lime"].onPopup = onPaletteItemPopup


palette.widgets["pink"] = widgets.Label.Create(palette, "pink")
palette.widgets["pink"].bgcolor = colors.pink
palette.widgets["pink"].caption = " "
palette.widgets["pink"].left = 4
palette.widgets["pink"].width = 2
palette.widgets["pink"].top = 3
palette.widgets["pink"].onClick = onPaletteItemClick
palette.widgets["pink"].onPopup = onPaletteItemPopup



palette.widgets["lightGray"] = widgets.Label.Create(palette, "lightGray")
palette.widgets["lightGray"].bgcolor = colors.lightGray
palette.widgets["lightGray"].caption = " "
palette.widgets["lightGray"].left = 2
palette.widgets["lightGray"].width = 2
palette.widgets["lightGray"].top = 4
palette.widgets["lightGray"].onClick = onPaletteItemClick
palette.widgets["lightGray"].onPopup = onPaletteItemPopup


palette.widgets["gray"] = widgets.Label.Create(palette, "gray")
palette.widgets["gray"].bgcolor = colors.gray
palette.widgets["gray"].caption = " "
palette.widgets["gray"].left = 4
palette.widgets["gray"].width = 2
palette.widgets["gray"].top = 4
palette.widgets["gray"].onClick = onPaletteItemClick
palette.widgets["gray"].onPopup = onPaletteItemPopup



palette.widgets["cyan"] = widgets.Label.Create(palette, "cyan")
palette.widgets["cyan"].bgcolor = colors.cyan
palette.widgets["cyan"].caption = " "
palette.widgets["cyan"].left = 2
palette.widgets["cyan"].width = 2
palette.widgets["cyan"].top = 5
palette.widgets["cyan"].onClick = onPaletteItemClick
palette.widgets["cyan"].onPopup = onPaletteItemPopup


palette.widgets["purple"] = widgets.Label.Create(palette, "purple")
palette.widgets["purple"].bgcolor = colors.purple
palette.widgets["purple"].caption = " "
palette.widgets["purple"].left = 4
palette.widgets["purple"].width = 2
palette.widgets["purple"].top = 5
palette.widgets["purple"].onClick = onPaletteItemClick
palette.widgets["purple"].onPopup = onPaletteItemPopup



palette.widgets["blue"] = widgets.Label.Create(palette, "blue")
palette.widgets["blue"].bgcolor = colors.blue
palette.widgets["blue"].caption = " "
palette.widgets["blue"].left = 2
palette.widgets["blue"].width = 2
palette.widgets["blue"].top = 6
palette.widgets["blue"].onClick = onPaletteItemClick
palette.widgets["blue"].onPopup = onPaletteItemPopup


palette.widgets["brown"] = widgets.Label.Create(palette, "brown")
palette.widgets["brown"].bgcolor = colors.brown
palette.widgets["brown"].caption = " "
palette.widgets["brown"].left = 4
palette.widgets["brown"].width = 2
palette.widgets["brown"].top = 6
palette.widgets["brown"].onClick = onPaletteItemClick
palette.widgets["brown"].onPopup = onPaletteItemPopup



palette.widgets["green"] = widgets.Label.Create(palette, "green")
palette.widgets["green"].bgcolor = colors.green
palette.widgets["green"].caption = " "
palette.widgets["green"].left = 2
palette.widgets["green"].width = 2
palette.widgets["green"].top = 7
palette.widgets["green"].onClick = onPaletteItemClick
palette.widgets["green"].onPopup = onPaletteItemPopup


palette.widgets["red"] = widgets.Label.Create(palette, "red")
palette.widgets["red"].bgcolor = colors.red
palette.widgets["red"].caption = " "
palette.widgets["red"].left = 4
palette.widgets["red"].width = 2
palette.widgets["red"].top = 7
palette.widgets["red"].onClick = onPaletteItemClick
palette.widgets["red"].onPopup = onPaletteItemPopup


palette.widgets["black"] = widgets.Label.Create(palette, "black")
palette.widgets["black"].bgcolor = colors.black
palette.widgets["black"].caption = " "
palette.widgets["black"].left = 2
palette.widgets["black"].width = 2
palette.widgets["black"].top = 8
palette.widgets["black"].onClick = onPaletteItemClick
palette.widgets["black"].onPopup = onPaletteItemPopup


palette.widgets["white"] = widgets.Label.Create(palette, "white")
palette.widgets["white"].bgcolor = colors.white
palette.widgets["white"].caption = " "
palette.widgets["white"].left = 4
palette.widgets["white"].width = 2
palette.widgets["white"].top = 8
palette.widgets["white"].onClick = onPaletteItemClick
palette.widgets["white"].onPopup = onPaletteItemPopup






function file_newClick()
	os.shell.run("paintbrush")
	app:terminate()
end

function file_openClick()
	--openDialog:execute()
	openFile()
	os.sendMessage(hwnd, {msg = "refresh"})
end

function file_saveClick()
	saveFile()
	os.sendMessage(hwnd, {msg = "refresh"})
end

function file_saveAsClick()
	saveDialog:execute()
	fileName = saveDialog.fileName
	--saveFile()
	os.sendMessage(hwnd, {msg = "refresh"})
end

function file_exitClick()
	app:terminate()
end

function edit_resizeClick()
	os.messageBox("input", "New canvas size: (eg. " .. app.canvas.size.x .. "x" .. app.canvas.size.y .. ")", "Resize Canvas", 
		{ 
			{caption = "Apply", 
				onClick = function(sender)
					os.hideMessageBox()
					local size = sender.parent.widgets.edit.text

					if size ~= nil then
						if string.find(size, "x") then
							local data = user.split(size, "x")
							local x = tonumber(data[1])
							local y = tonumber(data[2])

							if x ~= nil and y ~= nil then
								paintBox.height = y
								paintBox.width = x + 1
								os.sendMessage(hwnd, {msg = "refresh"})
							end
						end
					end
				end
			},

			{caption = "Cancel", 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
		}, paintBox.width - 1 .. "x" .. paintBox.height)
end




local fileMenu = widgets.PopupMenu.Create()
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New", function(sender) file_newClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Open", function(sender) file_openClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save", function(sender) file_saveClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Save As..", function(sender) file_saveAsClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Exit", function(sender) file_exitClick() end))

local editMenu = widgets.PopupMenu.Create()
table.insert(editMenu.items, widgets.PopupMenu.CreateItem("Resize", function(sender) edit_resizeClick() end))

local helpMenu = widgets.PopupMenu.Create()
table.insert(helpMenu.items, widgets.PopupMenu.CreateItem("About", function(sender) os.shell.run("winver Paintbrush") end))


local menu = widgets.MenuBar.Create(mainForm, "Menu")
table.insert(menu.items, widgets.MenuBar.CreateItem("File", function(sender) widgets.popupMenu(fileMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Edit", function(sender) widgets.popupMenu(editMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Help", function(sender) widgets.popupMenu(helpMenu, sender.left, sender.top + 2) end))


--os.startTimer(0.05, function() mainForm:refresh() end )
os.sendMessage(hwnd, {msg = "refresh"})
app:run()]])
table.insert(names, "/system2/pic.pic")
table.insert(values, [[pic|3|4|30*30*35 35 35 35 34 35 d5wd5wd5wd5w]])
table.insert(names, "/system2/ping.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Ping")

app:addForm(mainForm, "Ping")
mainForm:show()



function onSuccess(url, handle)
	local response = handle.readAll()
	handle.close()

	--mainForm.widgets.txtArea.text = response
	os.sendMessage(hwnd, {msg = "refresh"})
	app:showMessage(response)
end

function onFail(url)
	app:showMessage("Fail")
	--mainForm.widgets.txtArea.text = url
	os.sendMessage(hwnd, {msg = "refresh"})
end




local txtCmd = widgets.Edit.Create(mainForm, "txtCmd")
txtCmd.left = 2
txtCmd.top = 2
txtCmd.width = app.canvas.size.x - 2 - 10
txtCmd.text = ""


local btnCmd = widgets.Button.Create(mainForm, "btnCmd")
btnCmd.width = 9
btnCmd.left = app.canvas.size.x - btnCmd.width
btnCmd.top = 2
btnCmd.caption = " Run"


local txtArea = widgets.TextArea.Create(mainForm, "txtArea")
txtArea.left = 2
txtArea.top = 4
txtArea.width = app.canvas.size.x - 2
txtArea.height = app.canvas.size.y - txtArea.top - 1
--txtArea.visible = false



btnCmd.onClick = function(sender)
	if (txtCmd.text == nil) or (txtCmd.text == "") then
		os.messageBox("message", "Please specify any URL.", "Error", 
		{ 
			{caption = "OK", 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
		}, "defText")
	else
		local http = os.findWindowByTitle("http service")

		if http ~= nil then
			os.sendMessage(http, {msg = "request", url = txtCmd.text, postData = nil, headers = nil, onSuccess = onSuccess, onFail = onFail})
		else
			app:showMessage("Http service not found.\nPlease, reboot your computer.")
		end
	end
end

app:run()]])
table.insert(names, "/system2/procman.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Task Manager")

app:addForm(mainForm, "Task Manager")
mainForm:show()


local procList = widgets.ListBox.Create(mainForm, "procList")
procList.top = 4
procList.height = app.canvas.size.y - 7
procList.width = app.canvas.size.x + 1
procList.left = 0
procList.infoList = {}
procList.columns = 4
procList.columnWidth = { 14, app.canvas.size.x - 12 - 4 - 5 - 9, 5}



local lblInfo = widgets.Label.Create(mainForm, "lblInfo")
lblInfo.width = app.canvas.size.x
lblInfo.top = 3
lblInfo.left = 1
lblInfo.caption = "Window        Process"
local s = string.rep(" ", app.canvas.size.x - string.len(lblInfo.caption) - 12 - 1 - string.len("RAM") - 1)
lblInfo.caption = lblInfo.caption .. s .. "PID" .. "   " .. "RAM Usage"



local btnTerm = widgets.Button.Create(mainForm, "btnTerm")
btnTerm.width = 14
btnTerm.left = app.canvas.size.x - btnTerm.width
btnTerm.top = app.canvas.size.y - 2
btnTerm.caption = " Terminate"

btnTerm.onClick = function(sender)
	if procList.list[procList.index][3] > 0 then
		os.killProcess(procList.list[procList.index][3])
		sender.parent:refresh()
	end
end


lblPath = widgets.Label.Create(mainForm, "lblPath")
lblPath.width = app.canvas.size.x - btnTerm.width - 3
lblPath.top = app.canvas.size.y - 2
lblPath.left = 2
lblPath.forecolor = colors.gray

lblPath.onRefresh = function(sender)
	if procList.list[procList.index] ~= nil then
		local info = os.getProcessInfo(procList.list[procList.index][3])
		sender.caption = "home:/" .. (info.fileName or "")

		if sender.caption == "home:/" then sender.caption = "" end
	end
end



function GetProcessMemory(pid)
	return os.getProcessUsedMemory(pid)
end

function GetSystemMemory()
	return os.getProcessUsedMemory(-1)
end

function FormatProcessMemory(mem)
	if mem == -1 then
		return ""
	else
		local kBytes = mem / 1024

		if kBytes > 1000 then
			return tostring(user.round(mem / 1024 / 1024, 2)) .. " Mb"
		elseif kBytes > 100 then
			return tostring(user.round(mem / 1024, 1)) .. " Kb"	
		else
			return tostring(user.round(mem / 1024, 2)) .. " Kb"
		end
	end
end





mainForm.onRefresh = function(sender)
end


function refreshData(sender)
	sender.widgets.procList:clear()
	sender.widgets.procList.infoList = {}

	sender.widgets.procList:add({"System", " ", 0, FormatProcessMemory(GetSystemMemory()), 0})
	table.insert(sender.widgets.procList.infoList, {fileName = " ", hwnd = 0})

	for i, v in ipairs(os.getValidHWNDList(false)) do
		local info = os.getProcessInfo(v)

		sender.widgets.procList:add({info.title, os.extractFileName(info.fileName), info.hwnd, 
			FormatProcessMemory(GetProcessMemory(v)), tostring(info.etime / config.PROCESS_TIMER * 100) .. "%"})
		table.insert(sender.widgets.procList.infoList, {fileName = info.fileName, hwnd = v})
	end
end








function file_newClick()
	os.shell.run("exec.app")
end


function help_aboutClick()
end



local fileMenu = widgets.PopupMenu.Create()
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("New (Run..)", function(sender) file_newClick() end))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(fileMenu.items, widgets.PopupMenu.CreateItem("Exit", function(sender) app:terminate() end))

local helpMenu = widgets.PopupMenu.Create()
table.insert(helpMenu.items, widgets.PopupMenu.CreateItem("About", function(sender) help_aboutClick() end))


local menu = widgets.MenuBar.Create(mainForm, "Menu")
table.insert(menu.items, widgets.MenuBar.CreateItem("File", function(sender) widgets.popupMenu(fileMenu, sender.left, sender.top + 2) end))
table.insert(menu.items, widgets.MenuBar.CreateItem("Help", function(sender) widgets.popupMenu(helpMenu, sender.left, sender.top + 2) end))


os.startTimer(2, function()
	refreshData(mainForm)
	os.sendMessage(hwnd, {msg = "refresh"})
end )

refreshData(mainForm)
app:run()]])
table.insert(names, "/system2/setup.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local desktop = form.Create("Setup Wizard")


local lang = "EN-US"
local locale = iniFiles.read(os.getSystemPath() .. "/locale/" .. lang .. "/setup.ini").locale
local installing = false
local uninstalling = false

local setup = nil
if params[2] == nil then
	--error(locale["1"])
	setup = iniFiles.read("home:/Temp/Setup/setup.ini")
else
	setup = iniFiles.read(params[2])
end

setup.components.show = "false"

if params[3] == "-uninstall" then
	uninstalling = true
	setup.licanse.show = "false"
	setup.path.show = "false"
	setup.components.show = "false"
end



local function expandVars(s, p)
	local function getProgramPath()
		return "home:/Programs/"
	end

	local vars = {
		["%%APPNAME%%"]          = setup.application.name,
		["%%VERSION%%"]          = setup.application.version,
		["%%COMPANY%%"]          = setup.application.company,
		["%%PROGRAM%%"]          = getProgramPath(),
		["%%BLINDLY%%"]          = " ",
		["%%DESKTOP%%"]          = os.getSystemPath() .. "/userdata/Desktop/",
		["%%DOCUMENTS%%"]        = os.getSystemPath() .. "/userdata/Documents/",
		["%%PROGRAM_GROUPS%%"]   = os.getSystemPath() .. "/userdata/ProgramGroups/",
		["%%PROGRAMS%%"]         = os.getSystemPath() .. "/userdata/ProgramGroups/Programs/",
		["%%SETTINGS%%"]         = os.getSystemPath() .. "/userdata/ProgramGroups/Settings/",
		["%%SYSTEM%%"]           = os.getSystemPath(),
		["%%DRIVERS%%"]          = os.getSystemPath() .. "/drivers/",
		["%%SYSTEM_MODULES%%"]   = os.getSystemPath() .. "/system/",
		["%%SYSTEM_FILES%%"]     = os.getSystemPath() .. "/system2/",
		["%%CRAFTOS%%"]          = os.getSystemPath() .. "/sysWoW/",
	}

	if not p then vars["%%PATH%%"] = expandVars(setup.application.path, true) end
	if setup.license.blindly == "true" then vars["%%BLINDLY%%"] = " blindly " end

	for k, v in pairs(vars) do
		s = string.gsub(s, k, v)
	end

	return s
end
	



local frmStart = form.Create("Welcome")
app:addForm(frmStart, "Welcome")

local lbl1 = widgets.Label.Create(frmStart, "lbl1")
lbl1.left = 2
lbl1.top = 7
lbl1.caption = expandVars(locale["3"])
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1

local lbl2 = widgets.Label.Create(frmStart, "lbl2")
lbl2.left = 2
lbl2.top = 9
lbl2.caption = expandVars(locale["4"])
lbl2.width = app.canvas.size.x - 2
lbl2.height = 1

local lbl3 = widgets.Label.Create(frmStart, "lbl3")
lbl3.left = 2
lbl3.top = 10
lbl3.caption = expandVars(locale["5"])
lbl3.width = app.canvas.size.x - 2
lbl3.height = 1

local lbl4 = widgets.Label.Create(frmStart, "lbl4")
lbl4.left = 2
lbl4.top = 12
lbl4.caption = expandVars(locale["6"])
lbl4.width = app.canvas.size.x - 2
lbl4.height = 1

local picHeader1 = widgets.PaintBox.Create(frmStart, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local btnNext = widgets.Button.Create(frmStart, "btnNext")
btnNext.width = 9
btnNext.left = app.canvas.size.x - btnNext.width
btnNext.top = app.canvas.size.y - 2
btnNext.caption = expandVars(locale["1"])

local btnBack = widgets.Button.Create(frmStart, "btnBack")
btnBack.width = 9
btnBack.left = 2
btnBack.top = app.canvas.size.y - 2
btnBack.caption = expandVars(locale["7"])

btnBack.onClick = function(sender)
	os.messageBox("message", expandVars(locale["8"]), expandVars(locale["9"]), 
		{ 
			{caption = expandVars(locale["11"]), 
				onClick = function(sender)
					os.hideMessageBox()
				end
			},
			{caption = expandVars(locale["10"]), 
				onClick = function(sender)
					app:terminate()
				end
			},
		}, "defText")
end

local frmLicense = form.Create("License Agreement")
app:addForm(frmLicense, "License Agreement")

local frmPath = form.Create("Installation Path")
app:addForm(frmPath, "Installation Path")

local frmComponents = form.Create("Installation Components")
app:addForm(frmComponents, "Installation Components")

local frmReady = form.Create("Ready")
app:addForm(frmReady, "Ready")

btnNext.onClick = function(sender)
	if setup.license.show == "true" then
		frmLicense:show()
	else
		if setup.path.show == "true" then
			frmPath:show()
		else
			if setup.components.show == "true" then
				frmComponents:show()
			else
				frmReady:show()
			end
		end
	end
end




local txtLicense = widgets.TextArea.Create(frmLicense, "txtLicense", widgets)
txtLicense.left = 2
txtLicense.top = 2
txtLicense.height = app.canvas.size.y - 7
txtLicense.width = app.canvas.size.x - 2
txtLicense.text = ""

if fs.exists("/Temp/Setup/" .. setup.license.file) then
	local file = fs.open("/Temp/Setup/" .. setup.license.file, "r")
	txtLicense.text = file.readAll()
	file.close()
end

local chkAccept = widgets.CheckBox.Create(frmLicense, "chkAccept")
chkAccept.left = 2
chkAccept.top = txtLicense.height + 3
chkAccept.width = app.canvas.size.x - 2
chkAccept.caption = expandVars(locale["12"])
chkAccept.checked = false

local btnNext = widgets.Button.Create(frmLicense, "btnNext")
btnNext.width = 9
btnNext.left = app.canvas.size.x - btnNext.width
btnNext.top = app.canvas.size.y - 2
btnNext.caption = expandVars(locale["1"])

local btnBack = widgets.Button.Create(frmLicense, "btnBack")
btnBack.width = 9
btnBack.left = 2
btnBack.top = app.canvas.size.y - 2
btnBack.caption = expandVars(locale["2"])

btnBack.onClick = function(sender)
	frmStart:show()
end

btnNext.onClick = function(sender)
	if chkAccept.checked then
		if setup.path.show == "true" then
			frmPath:show()
		else
			if setup.components.show == "true" then
				frmComponents:show()
			else
				frmReady:show()
			end
		end
	else
		os.messageBox("message", expandVars(locale["13"]), expandVars(locale["14"]), 
			{ 
				{caption = expandVars(locale["15"]), 
					onClick = function(sender)
						os.hideMessageBox()
					end
				},
			}, "defText")
	end
end



local openDialog = widgets.dialogs.OpenDialog.Create(frmPath, "OpenDialog")
openDialog.dirOnly = true

openDialog.onExecute = function(sender)
	sender.parent.widgets.txtPath.text = sender.fileName or sender.parent.widgets.txtPath.text
	os.sendMessage(hwnd, {msg = "refresh"})
end

local picHeader1 = widgets.PaintBox.Create(frmPath, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local lbl1 = widgets.Label.Create(frmPath, "lbl1")
lbl1.left = 2
lbl1.top = 9
lbl1.caption = expandVars(locale["16"])
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1

local txtPath = widgets.Edit.Create(frmPath, "txtPath")
txtPath.width = app.canvas.size.x - 6
txtPath.left = 2
txtPath.top = 11
txtPath.text = expandVars("%PATH%")

local btnBrowse = widgets.Button.Create(frmPath, "btnBrowse")
btnBrowse.width = 2
btnBrowse.left = app.canvas.size.x - btnBrowse.width
btnBrowse.top = 11
btnBrowse.forecolor2 = btnBrowse.forecolor
btnBrowse.caption = ".."
btnBrowse.onClick = function(sender)
	openDialog:execute()
end

if setup.path.editable == "false" then
	btnBrowse.visible = false
	txtPath.editable = false
	txtPath.width = txtPath.width + 4
end

local btnNext = widgets.Button.Create(frmPath, "btnNext")
btnNext.width = 9
btnNext.left = app.canvas.size.x - btnNext.width
btnNext.top = app.canvas.size.y - 2
btnNext.caption = expandVars(locale["1"])

local btnBack = widgets.Button.Create(frmPath, "btnBack")
btnBack.width = 9
btnBack.left = 2
btnBack.top = app.canvas.size.y - 2
btnBack.caption = expandVars(locale["2"])

btnBack.onClick = function(sender)
	if setup.license.show == "true" then
		frmLicense:show()
	else
		frmStart:show()
	end
end

btnNext.onClick = function(sender)
	if setup.components.show == "true" then
		frmComponents:show()
	else
		frmReady:show()
	end
end




local picHeader1 = widgets.PaintBox.Create(frmComponents, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local lstComponents = widgets.ListBox.Create(frmComponents, "lstComponents", widgets)
lstComponents.left = 0
lstComponents.top = 7
lstComponents.height = app.canvas.size.y - 14
lstComponents.width = app.canvas.size.x + 1
lstComponents.checkBoxes = true




local picHeader1 = widgets.PaintBox.Create(frmReady, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local lbl1 = widgets.Label.Create(frmReady, "lbl1")
lbl1.left = 2
lbl1.top = 7
lbl1.caption = expandVars(locale["17"])
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1

local lbl2 = widgets.Label.Create(frmReady, "lbl2")
lbl2.left = 2
lbl2.top = 9
lbl2.caption = expandVars(locale["19"])
lbl2.width = app.canvas.size.x - 2
lbl2.height = 1

local lbl3 = widgets.Label.Create(frmReady, "lbl3")
lbl3.left = 2
lbl3.top = 10
lbl3.caption = expandVars(locale["20"])
lbl3.width = app.canvas.size.x - 2
lbl3.height = 1

local lbl4 = widgets.Label.Create(frmReady, "lbl4")
lbl4.left = 2
lbl4.top = 12
lbl4.caption = expandVars(locale["18"])
lbl4.width = app.canvas.size.x - 2
lbl4.height = 1

local frmProgress = form.Create("Installation in progress...")
app:addForm(frmProgress, "Installation in progress...")
--frmProgress.controlBox = false

local btnNext = widgets.Button.Create(frmReady, "btnNext")
btnNext.width = 9
btnNext.left = app.canvas.size.x - btnNext.width
btnNext.top = app.canvas.size.y - 2
btnNext.caption = expandVars(locale["1"])

local btnBack = widgets.Button.Create(frmReady, "btnBack")
btnBack.width = 9
btnBack.left = 2
btnBack.top = app.canvas.size.y - 2
btnBack.caption = expandVars(locale["2"])

btnBack.onClick = function(sender)
	if setup.components.show == "true" then
		frmComponents:show()
	else
		if setup.path.show == "true" then
			frmPath:show()
		else
			if setup.license.show == "true" then
				frmLicense:show()
			else
				frmStart:show()
			end
		end
	end
end


local picHeader1 = widgets.PaintBox.Create(frmProgress, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local lblStatus = widgets.Label.Create(frmProgress, "lblStatus")
lblStatus.left = 2
lblStatus.top = 12
lblStatus.caption = ""
lblStatus.width = app.canvas.size.x - 2
lblStatus.height = 1

local pbProgress = widgets.ProgressBar.Create(frmProgress, "pbProgress")
pbProgress.left = 2
pbProgress.top = 10
pbProgress.caption = ""
pbProgress.width = app.canvas.size.x - 2
pbProgress.height = 1



local frmSuccess = form.Create("Installation Complete")
app:addForm(frmSuccess, "Installation Complete")



btnNext.onClick = function(sender)
	frmProgress:show()

	app:createThread(function()
		local function installPackage(name)
			local function countFiles(path)
				local result = 0
				local ls = fs.list(tostring(string.gsub(path, "home:/", "")))
				pbProgress.max = #ls
				pbProgress.position = 0
				coroutine.yield()

				for i, v in ipairs(ls) do
					if (v ~= ".") and (v ~= "..") then
						if fs.isDir(tostring(string.gsub(path, "home:/", "") .. "/" .. v)) then
							result = result + countFiles(path .. "/" .. v)
						else
							result = result + 1
							pbProgress.position = pbProgress.position + 1
							coroutine.yield()
						end
					end
				end
				return result
			end

			local function copyFiles(parent, path)
				local fullPath = tostring(string.gsub(parent .. "/" .. path, "home:/", ""))
				local ls = fs.list(fullPath)
				for k, v in pairs(ls) do
					if fs.isDir(fullPath .. "/" .. v) then
						copyFiles(parent, path .. "/" .. v)
					else
						local copyTo = tostring(string.gsub(expandVars("%PATH%"), "home:/", "/"))
						fs.makeDir(copyTo .. "/" .. path)

						local status, message = pcall(function()
							fs.copy(fullPath .. "/" .. v, copyTo .. "/" .. path .. "/" .. v)
						end)
						if not status then
							if string.find(message, "exist") and setup.application.override == "true" then
								fs.delete(copyTo .. "/" .. path .. "/" .. v)
								fs.copy(fullPath .. "/" .. v, copyTo .. "/" .. path .. "/" .. v)
							end
						end

						pbProgress.position = pbProgress.position + 1
						coroutine.yield()
					end
				end
			end

			lblStatus.caption = expandVars(locale["21"])
			
			local package = iniFiles.read("home:/Temp/Setup/" .. name .. "/package.ini")
			local total = countFiles("home:/Temp/Setup/" .. name .. "/data/")

			pbProgress.max = total
			pbProgress.position = 0
			lblStatus.caption = ""
			coroutine.yield()

			lblStatus.caption = expandVars(locale["22"])
			copyFiles("home:/Temp/Setup/" .. name .. "/data", "/")
			lblStatus.caption = ""
			coroutine.yield()

			pbProgress.position = 0
			lblStatus.caption = expandVars(locale["29"])
			coroutine.yield()

			local shortcuts = iniFiles.read("home:/Temp/Setup/" .. name .. "/shortcuts.ini")
			pbProgress.max = 0
			for k, v in pairs(shortcuts) do
				pbProgress.max = pbProgress.max + 1
			end

			for k, v in pairs(shortcuts) do
				local shortcut = {
					shortcut = {
						file = expandVars(v.path),
						icon = expandVars(v.icon),
					}
				}
				iniFiles.write(expandVars(v.location), shortcut)
				pbProgress.position = pbProgress.position + 1
				coroutine.yield()
			end

		end

		installing = true
		installPackage(setup.components.default)

		pbProgress.position = 0
		lblStatus.caption = ""
		coroutine.yield()
		
		if setup.after.run == "true" then
			os.shell.run(setup.after.cmd)
		end

		frmSuccess:show()
		coroutine.yield()
		installing = false
	end)
end



local picHeader1 = widgets.PaintBox.Create(frmSuccess, "picHeader")
picHeader1.left = 0
picHeader1.top = 1
picHeader1.width = app.canvas.size.x + 1
picHeader1.height = 5
picHeader1:refresh()
if fs.exists("/Temp/Setup/" .. setup["application"].header) then
	local canvas = user.loadCanvas("home:/Temp/Setup/" .. setup.application.header):scale(picHeader1.width, picHeader1.height)
	picHeader1.canvas:draw(0, 0, canvas)
end

local lbl1 = widgets.Label.Create(frmSuccess, "lbl1")
lbl1.left = 2
lbl1.top = 7
lbl1.caption = expandVars(locale["24"])
lbl1.width = app.canvas.size.x - 2
lbl1.height = 1

local lbl2 = widgets.Label.Create(frmSuccess, "lbl2")
lbl2.left = 2
lbl2.top = 8
lbl2.caption = expandVars(locale["25"])
lbl2.width = app.canvas.size.x - 2
lbl2.height = 1

local chkRun = widgets.CheckBox.Create(frmSuccess, "chkRun")
chkRun.left = 2
chkRun.top = 11
chkRun.caption = expandVars(locale["27"])
chkRun.width = app.canvas.size.x - 2
chkRun.height = 1
chkRun.checked = setup.run_installed.checked == "true"

local chkReadme = widgets.CheckBox.Create(frmSuccess, "chkReadme")
chkReadme.left = 2
chkReadme.top = 13
chkReadme.caption = expandVars(locale["28"])
chkReadme.width = app.canvas.size.x - 2
chkReadme.height = 1
chkReadme.checked = setup.show_readme.checked == "true"

if setup.run_installed.show == "false" then
	chkRun.visible = false
	chkReadme.top = 11
end

if setup.show_readme.show == "false" then
	chkReadme.visible = false
end



local btnNext = widgets.Button.Create(frmSuccess, "btnNext")
btnNext.width = 9
btnNext.left = app.canvas.size.x - btnNext.width
btnNext.top = app.canvas.size.y - 2
btnNext.caption = expandVars(locale["26"])

btnNext.onClick = function(sender)
	if chkRun.visible and chkRun.checked then
		os.shell.run(expandVars(setup.run_installed.cmd))
	end

	if chkReadme.visible and chkReadme.checked then
		os.shell.run(expandVars(setup.show_readme.cmd))
	end

	app:terminate()
end




local frmFailure = form.Create("Installation Failed")
app:addForm(frmFailure, "Installation Failed")



os.startTimer(0.01, function() if installing then os.sendMessage(hwnd, {msg = "refresh"}) end end)


app.activeForm = frmStart
app:run()]])
table.insert(names, "/system2/shldr.app")
table.insert(values, [[if config.AUTORUN ~= nil then
	for k, v in pairs(config.AUTORUN) do
		os.shell.run(v)
	end
end]])
table.insert(names, "/system2/shutdown.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local mainForm = form.Create("Shut Down")
app:addForm(mainForm, "Shut Down")
mainForm:show()
mainForm.controlBox = false


local lblCmd = widgets.Label.Create(mainForm, "lblCmd")
lblCmd.left = 2
lblCmd.top = 2
lblCmd.width = app.canvas.size.x - 2
lblCmd.caption = "What do you want the computer to do?"

local top = math.floor(app.canvas.size.y / 2) - 6


lblShutdown = widgets.Label.Create(mainForm, "lblShutdown")
lblShutdown.left = 5
lblShutdown.top = 4 + top
lblShutdown.width = app.canvas.size.x - 9
lblShutdown.caption = "-> Shut Down"
lblShutdown.forecolor = colors.blue

lblShutdown.onClick = function(sender)
	os.shell.shutdown()
end


lblRestart = widgets.Label.Create(mainForm, "lblRestart")
lblRestart.left = 5
lblRestart.top = 6 + top
lblRestart.width = app.canvas.size.x - 9
lblRestart.caption = "-> Restart"
lblRestart.forecolor = colors.blue

lblRestart.onClick = function(sender)
	os.shell.restart()
end


lblRestart2 = widgets.Label.Create(mainForm, "lblRestart2")
lblRestart2.left = 5
lblRestart2.top = 8 + top
lblRestart2.width = app.canvas.size.x - 9
lblRestart2.caption = "-> Restart in CraftOS mode"
lblRestart2.forecolor = colors.blue


lblRestart2.onClick = function(sender)
	os.shell.restart(true)
end


btnCancel = widgets.Button.Create(mainForm, "btnCancel")
btnCancel.left = app.canvas.size.x - 10
btnCancel.top = app.canvas.size.y - 2
btnCancel.width = 10
btnCancel.caption = "Cancel"

btnCancel.onClick = function(sender)
	app:terminate()
end







os.getProcessInfo(os.getCurrentProcess()).showInTaskbar = false
app:run()]])
table.insert(names, "/system2/taskbar.app")
table.insert(values, [[local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local taskbar = form.Create("Taskbar")
local processCount = 0
local refreshCount = 0
local useAM = true
local scroll = 0
local shouldScroll = false

app:addForm(taskbar, "Taskbar")
taskbar:show()

os.getProcessInfo(os.getCurrentProcess()).showInTaskbar = false


local time = widgets.Label.Create(taskbar, "Time")
time.width = 7
time.left = app.canvas.size.x - time.width + 2
time.top = 0
time.align = "right"
time.bgcolor = colors.gray
time.forecolor = colors.white

time.onClick = function(sender)
	--if useAM then useAM = false else useAM = true end
end

time.onRefresh = function(sender)
	sender.caption = tostring(textutils.formatTime(os.time(), useAM)) .. "%"
end



local leftButton = widgets.Button.Create(taskbar, "leftButton")
leftButton.caption = "<"
leftButton.left = 9
leftButton.width = 1
leftButton.top = 0
leftButton.forecolor2 = colors.lightGray

leftButton.onClick = function(sender)
	if shouldScroll then
		scroll = scroll + 4
		if scroll > 0 then scroll = 0 end
	end
end


local rightButton = widgets.Button.Create(taskbar, "rightButton")
rightButton.caption = ">"
rightButton.left = 10 + app.canvas.size.x - 9 - 6 - 2 + 1
rightButton.width = 1
rightButton.top = 0
rightButton.forecolor2 = colors.lightGray

rightButton.onClick = function(sender)
	if shouldScroll then
		scroll = scroll - 4
		if scroll < -10 * (processCount - 1) + processCount - 1 then scroll = -10 * (processCount - 1) + processCount - 1 end
	end
end




local panel = widgets.Panel.Create(taskbar, "Panel")
panel.top = 0
panel.height = 2
panel.width = app.canvas.size.x - 9 - 6 - 2
panel.left = 10
panel.bgcolor = colors.gray

--app.canvas:fillrect(1, 1, app.canvas.size.x, 1, colors.gray)

panel.onRefresh = function(sender)
	local hwnds = os.getValidHWNDList(true)

	if processCount > 0 then
		for i = 0, processCount do
			sender.widgets["button_" .. tostring(i)] = nil
		end
	end


	if #hwnds > 3 then
		shouldScroll = true
		leftButton.visible = true
		rightButton.visible = true

		if processCount ~= #hwnds then
			scroll = -10 * (#hwnds - 3) - #hwnds + 3
		end
	else
		shouldScroll = false
		leftButton.visible = false
		rightButton.visible = false
		scroll = 0
	end


	processCount = #hwnds
	sender.focusedWidget = nil




	for i, v in ipairs(hwnds) do
		local button = widgets.Button.Create(sender, "button_" .. tostring(i))
		local info = os.getProcessInfo(v)
		button.width = 10
		button.left = scroll + button.width * (i - 1) + i
		button.caption = --\[\["|" .. \]\]info.title
		button.tag = v
		button.forecolor2 = colors.white

		if v == os.getActiveProcess() then
			button.bgcolor = colors.lightGray
			button.forecolor = colors.black
			button.forecolor2 = colors.black
		end

		button.onClick = function(sender)
			sender.bgcolor = colors.lightGray
			sender.forecolor = colors.black
			sender.forecolor2 = colors.black
			os.setActiveProcess(sender.tag)
		end
	end
end



function shutDown()
	os.shell.run("shutdown.app")
--\[\[	os.messageBox("message", "What do you want the computer to do?", "Shut Down", 
	{ 
		{caption = "Shut Down", 
			onClick = function(sender)
				os.hideMessageBox()
			end
		},

		{caption = "Restart",
			onClick = function(sender)
				os.hideMessageBox()
			end
		},

		{caption = "Restart in CraftOS mode",
			onClick = function(sender)
				os.hideMessageBox()
			end
		},

		{caption = "Cancel",
			onClick = function(sender)
				os.hideMessageBox()
			end
		}

	}, "defText")\]\]
end


local startMenu = widgets.PopupMenu.Create()
startMenu.forecolor2 = colors.red
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Shut Down..", function(sender) shutDown() end))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Run..", function(sender) os.shell.run("exec.app") end))
--table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Help", nil))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("-", nil))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Settings", function(sender) os.shell.run("explorer \"" .. os.getSystemPath() .. 
	"/userdata/ProgramGroups/Settings/\"") end))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Documents", function(sender) os.shell.run("explorer \"" .. os.getSystemPath() .. 
	"/userdata/Documents/\"") end))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("Programs", function(sender) os.shell.run("explorer \"" .. os.getSystemPath() .. 
	"/userdata/ProgramGroups/Programs/\"") end))
table.insert(startMenu.items, widgets.PopupMenu.CreateItem("   ", nil))


local start = widgets.Button.Create(taskbar, "Start")
start.left = 1
start.top = 0
start.width = 7
start.bgcolor = colors.blue
start.forecolor = colors.white
start.caption = " Start"

start.onClick = function(sender)
	--startMenu:popUp(1, sender.parent:getCanvas().size.y - 2)
	widgets.popupMenu(startMenu, 1, sender.parent:getCanvas().size.y)
end






taskbar.onRefresh = function(sender)
	app.canvas:fillrect(1, 1, app.canvas.size.x, 1, colors.gray)
end

taskbar.onTerminate = function(sender)
	return false
end


os.startTimer(0.05, function() taskbar:refresh() end )
app:run()]])
table.insert(names, "/system2/txt.pic")
table.insert(values, [[pic|3|4|bc bc bc bc 0b=0b=0b=0b=0b=0bt0bx0bt]])
table.insert(names, "/system2/unknown.pic")
table.insert(values, [[pic|3|4|80 80 80 80 80 80?80?80 80 80 80 80 ]])
table.insert(names, "/system2/win.ini")
table.insert(values, [[[extensions]
lua = luaedit.app "%FILENAME%"
ini = luaedit.app "%FILENAME%"
txt = notepad.app "%FILENAME%"
lnk = lnkview.app "%FILENAME%"
pic = paintbrush.app "%FILENAME%"
[system]
timer = 0.05
[installed]
Notepad = notepad.app "%FILENAME%"
Lua Editor = luaedit.app "%FILENAME%"
Paintbrush = paintbrush.app "%FILENAME%"
[desktop]
bgcolor = 512]])
table.insert(names, "/system2/winver.app")
table.insert(values, [[function CreateEffect(speed)
	local function RANDOMCOLOR(COLOR_BASE)
		local COLORS = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768 }
		math.randomseed(COLOR_BASE * os.time())

		if COLORS[math.random(1, 16)] ~= nil then
			return COLORS[math.random(1, 16)]
		else
			return colors.white
		end
	end

	local effect = {
		i = 0,
		speed = speed or 1,

		getbgcolor = function(self, x, y, bgcolor, forecolor, char)
			return bgcolor
		end,

		getforecolor = function(self, x, y, bgcolor, forecolor, char)
			self.i = self.i + self.speed
			local color = RANDOMCOLOR(self.i)
			if color == bgcolor then color = colors.white end
			return color
		end,

		getchar = function(self, x, y, bgcolor, forecolor, char)
			return char
		end,
	}

	return effect
end



local app = application.Create(os.getProcessInfo(os.getCurrentProcess()), os)
local frmMain = form.Create("About CCWin...")

app:addForm(frmMain, "About CCWin...")
frmMain:show()



local logo = widgets.PaintBox.Create(frmMain, "logo")
local logoImg = user.loadCanvas(os.getSystemPath() .. "/logo.pic")
logo.height = logoImg.size.y
logo.width = logoImg.size.x
logo.top = 2
logo.left = math.ceil(app.canvas.size.x / 2) - math.floor(logo.width / 2)
logo.canvas = logoImg
logo.canvas.effect = CreateEffect()


local lbl = widgets.Label.Create(frmMain, "lbl1")
lbl.top = 3 + logo.height
lbl.width = app.canvas.size.x
lbl.align = "center"
lbl.caption = " CCWIN 0.9"

local lbl = widgets.Label.Create(frmMain, "lbl2")
lbl.top = 3 + logo.height + 2
lbl.width = app.canvas.size.x
lbl.align = "center"
lbl.caption = "(c) Puzzletime, 2014-2015"


local btn = widgets.Button.Create(frmMain, "btn")
btn.top = app.canvas.size.y - 2
btn.caption = " Close"
btn.onClick = function(sender) app:terminate() end
btn.width = 9
btn.left = math.floor(app.canvas.size.x / 2 - btn.width / 2) + 1




local magic = widgets.Panel.Create(frmMain, "magic")
magic.height = 1
magic.width = app.canvas.size.x
magic.top = app.canvas.size.y - 4
magic.left = 0

magic.onRefresh = function(sender)
	if sender.canvas ~= nil and sender.canvas.effect == nil then
		sender.canvas.effect = CreateEffect(100000)
	end
end

local lbl = widgets.Label.Create(magic, "lbl")
lbl.width = app.canvas.size.x
lbl.align = "center"
lbl.caption = " Do you believe in magic?"

lbl.onClick = function(sender)
	if os.getMagic() == nil then
		os.applyMagic(user.CreateEffect_Acid())
	else
		os.applyMagic(nil)
	end
end




os.startTimer(0.1, function() os.sendMessage(hwnd, {msg = "refresh"}) end )
app:run()]])
table.insert(names, "/sysWoW/cmd")
table.insert(values, [[local path = "$CURRENT$|$WIN$/sysWoW/|$WIN$/system2/|$WIN$/userdata/documents/|home:/rom/programs/|home:/"
local current_path = "$WIN$/userdata/documents/"
local history = {}


-- /* http://lua-users.org/wiki/SplitJoin */ --
function string:split(sep)
	local sep, fields = sep or ":", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end


local function expandEnvironmentVars(s)
	return string.gsub(string.gsub(s, "$CURRENT$", current_path), "$WIN$", "home:/" .. os.getSystemPath)
end


local function resolvePath(s)
	s = string.split(expandEnvironmentVars(path), "|")
	for i, v in ipairs(s) do
		if fs.exists(path .. v) then
			return path .. v
		end
	end
end


print("CCWin [Version 1.0]")
print("(c) Puzzletime, 2014-2015")
print("")


while true do
	print(expandEnvironmentVars(current_path) .. "> ")
	command = read(nil, history)
	table.insert(history)

	if string.lower(cmd) == "programs" then
	else
		shell.run(cmd)
		--args = string.split(cmd, " ")
		--local p = resolvePath(cmd)
	end
end]])
table.insert(names, "/sysWoW/pack")
table.insert(values, [[local args = {...}
local path = args[2]
local filename = args[3]
local self_extract = args[4]

if not xwin then
	path = args[1]
	filename = args[2]
	self_extract = args[3]
end

print(path)
print(filename)
print(self_extract)


function flist(base, path)
	local l = fs.list(base .. "/" .. path)
	local ls = {}

	for k, v in pairs(l) do
		pcall(function()
			if fs.isDir(base .. "/" .. path .. "/" .. v) then
				local files = flist(base, path .. "/" .. v)
				for kq, vq in pairs(files) do
					table.insert(ls, vq)
				end
			else
				table.insert(ls, path .. "/" .. v)
			end
		end)
	end

	return ls
end


local data = {}
table.insert(data, "local names = {}\nlocal values = {}\n")
local files = flist("/" .. path, "")
for k, v in pairs(files) do
	pcall(function()
		if not fs.isDir(path .. "/" .. v) then
			local file = fs.open(path .. "/" .. v, "r")
			local s = file.readAll()
			file.close()

			table.insert(data, "table.insert(names, \"" .. v .. "\")\n")
			s = string.gsub(s, "%[%[", "\\%[\\%[")
			s = string.gsub(s, "%]%]", "\\%]\\%]")
			table.insert(data, "table.insert(values, \[\[" .. s .. "\]\])\n")
		end
	end)
end


if self_extract == "-se" then
	local se_code = \[\[
local args = {...}
local path = args[2] or "/temp"
if not xwin then
	path = args[1] or "/temp"
end

function _utStrSplit(self, sep)
	local sep, fields = sep or ":", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end

print("Unpacking LRC...")

fs.makeDir(path)
for i = 1, #names do
	local l = _utStrSplit(names[i], "/")
	local p = ""
	if #l > 1 then
		pcall(function()
			for i = 1, #p - 2 do
				p = p .. "/" .. l[i]
			end
		end)
	end

	pcall(function()
		fs.makeDir(path .. "/" .. p)
		local file = fs.open(path .. "/" .. names[i], "w")
		values[i] = string.gsub(values[i], "\\%[\\%[", "%[%[")
		values[i] = string.gsub(values[i], "\\%]\\%]", "%]%]")
		file.write(values[i])
		file.close()
	end)
end
print("Done!")\]\]
	table.insert(data, se_code)
else
	table.insert(data, "return names, values")
end



filename = "/" .. filename
local f = fs.open(filename, "w")

for i, v in ipairs(data) do
	f.write(v)
end

f.close()
print("Success!")]])
table.insert(names, "/sysWoW/ping")
table.insert(values, [[args = {...}
if (type(args[1]) ~= "string") or (string.lower(args[1]) == "help") then
	print("usage: ping %url& [%n%]")
	return
end

print(args[1])
args[2] = args[2] or 4
local times = {}
local avg = 0

for i = 1, args[2] do
	local t = os.time()
	local h = http.get(args[1])

	if h == nil then
		print(tostring(i) .. ": Could not connect to host")
	else
		local c = os.time() - t
		table.insert(times, c)
		print(tostring(i) .. ": " .. tostring(c) .. "s")
	end
end

for i, v in ipairs(times) do
	avg = avg + v
end

avg = avg / #times

print("")
print("Average: " .. tostring(avg) .. "s")]])
table.insert(names, "/sysWoW/rombios")
table.insert(values, [[G_ENV = {}



-- /* http://lua-users.org/wiki/SplitJoin */ --
function string:split(sep)
	local sep, fields = sep or ":", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end

function stringstarts(String,Start)
   return string.sub(String,1,string.len(Start))==Start
end

function stringends(String,End)
   return End=='' or string.sub(String,-string.len(End))==End
end



function os.run(env, file, ...)
	local fenv = {}
	env = env or {}
	for k, v in pairs(getfenv(1)) do
		fenv[k] = v
	end
	for k, v in pairs(env) do
		fenv[k] = v
	end

	local p = assert(loadfile(file))

	setfenv(p, fenv)
	G_ENV = fenv

	local args = args or {...}

	if type(args) ~= "table" then
		if type(args) == "string" then
			local argList = string.split(args, " ")
			local argsNew = {}
			local cArg = ""
			for i, v in ipairs(argList) do
				local added = false
				if stringstarts(v, "\"") and string.len(cArg) == 0 then
					cArg = v
					added = true
				end

				if stringends(v, "\"") and string.len(cArg) ~= 0 then
					table.insert(argsNew, cArg)
					added = true
				end

				if not added then
					table.insert(argsNew, v)
				end
			end

			args = argsNew
		else
			args = {args}
		end
	end
	--error(args)

	local thread = coroutine.create(p)
	local running = true

	while running do
		if coroutine.status(thread) ~= "dead" then
			coroutine.resume(thread, unpack(args))
			coroutine.yield()
		else
			running = false
		end
	end
	--p(unpack(args))
end


local oldLoadAPI = os.loadAPI
function os.loadAPI(fn)
	code = loadfile(fn)
	fn = string.split(fn, "/")
	fn = fn[#fn]

	local lib = {}
	setmetatable(lib, { __index = getfenv() })
	setfenv(code, lib)

	result, err = pcall(code)
	if not result then
		error(err)
	end

	local final = {}
	for k, v in pairs(lib) do
		final[k] = v
	end

	if G_ENV[fn] == nil then
		G_ENV[fn] = final
	end

	return final
end


sleep = function(t)
	--print("sleeping " .. tostring(t))
	os.sleep(t)
end


term.native = function()
	return term
end


_EMULATED = true


window = os.loadAPI("rom/apis/window")
textutils = os.loadAPI("rom/apis/textutils")
colors = os.loadAPI("rom/apis/colors")
colours = os.loadAPI("rom/apis/colours")

os.run(nil, "/rom/programs/shell")
--os.run(nil, "/romtest")]])
table.insert(names, "/userdata/Desktop/Explorer.lnk")
table.insert(values, [[[shortcut]
file = explorer
icon = home:/CCWin/system2/folder.pic]])
table.insert(names, "/userdata/Desktop/LUAEdit.lnk")
table.insert(values, [[[shortcut]
file = luaedit
icon = home:/CCWin/system2/lua.pic]])
table.insert(names, "/userdata/Desktop/ncvm.lnk")
table.insert(values, [[[shortcut]
file = home:/CCWin/system2/ncvm.app
icon = home:/CCWin/system2/app.pic]])
table.insert(names, "/userdata/Desktop/New Notepad.lnk")
table.insert(values, [[[shortcut]
file = home:/Programs//MyCorp/TestApplication/1.0.0//notepad.lnk
icon = CCWin//system2//pic.pic]])
table.insert(names, "/userdata/Desktop/Notepad.lnk")
table.insert(values, [[[shortcut]
file = notepad
icon = home:/CCWin/system2/txt.pic]])
table.insert(names, "/userdata/Desktop/Paintbrush.lnk")
table.insert(values, [[[shortcut]
file = paintbrush
icon = home:/CCWin/system2/pic.pic]])
table.insert(names, "/userdata/Desktop/setup.lnk")
table.insert(values, [[[shortcut]
file = home://CCWin/system2/setup.app
icon = home:/CCWin/system2/app.pic]])
table.insert(names, "/userdata/ProgramGroups/Programs/Explorer.lnk")
table.insert(values, [[[shortcut]
file = home:/CCWin/system2/explorer.app
icon = home:/CCWin/system2/folder.pic]])
table.insert(names, "/userdata/ProgramGroups/Programs/LUAEdit.lnk")
table.insert(values, [[[shortcut]
file = luaedit
icon = home:/CCWin/system2/lua.pic]])
table.insert(names, "/userdata/ProgramGroups/Programs/Notepad.lnk")
table.insert(values, [[[shortcut]
file = notepad
icon = home:/CCWin/system2/txt.pic]])
table.insert(names, "/userdata/ProgramGroups/Programs/Paintbrush.lnk")
table.insert(values, [[[shortcut]
file = home:/CCWin/system2/paintbrush.app
icon = home:/CCWin/system2/pic.pic]])
table.insert(names, "/userdata/ProgramGroups/Settings/Boot.ini.lnk")
table.insert(values, [[[shortcut]
file = home:/boot.ini
icon = home:/CCWin/system2/ini.pic]])
table.insert(names, "/userdata/ProgramGroups/Settings/Win.ini.lnk")
table.insert(values, [[[shortcut]
file = home:/CCWin/system2/win.ini
icon = home:/CCWin/system2/ini.pic]])
return names, values